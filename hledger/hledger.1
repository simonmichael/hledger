.\"t

.TH "hledger" "1" "June 2020" "hledger 1.18" "hledger User Manuals"



.SH NAME
.PP
hledger - a command-line accounting tool
.SH SYNOPSIS
.PP
\f[C]hledger [-f FILE] COMMAND [OPTIONS] [ARGS]\f[R]
.PD 0
.P
.PD
\f[C]hledger [-f FILE] ADDONCMD -- [OPTIONS] [ARGS]\f[R]
.PD 0
.P
.PD
\f[C]hledger\f[R]
.SH DESCRIPTION
.PP
hledger is a reliable, cross-platform set of programs for tracking
money, time, or any other commodity, using double-entry accounting and a
simple, editable file format.
hledger is inspired by and largely compatible with ledger(1).
.PP
This is hledger\[cq]s command-line interface (there are also terminal
and web interfaces).
Its basic function is to read a plain text file describing financial
transactions (in accounting terms, a general journal) and print useful
reports on standard output, or export them as CSV.
hledger can also read some other file formats such as CSV files,
translating them to journal format.
Additionally, hledger lists other hledger-* executables found in the
user\[cq]s $PATH and can invoke them as subcommands.
.PP
hledger reads data from one or more files in hledger journal, timeclock,
timedot, or CSV format specified with \f[C]-f\f[R], or
\f[C]$LEDGER_FILE\f[R], or \f[C]$HOME/.hledger.journal\f[R] (on windows,
perhaps \f[C]C:/Users/USER/.hledger.journal\f[R]).
If using \f[C]$LEDGER_FILE\f[R], note this must be a real environment
variable, not a shell variable.
You can specify standard input with \f[C]-f-\f[R].
.PP
Transactions are dated movements of money between two (or more) named
accounts, and are recorded with journal entries like this:
.IP
.nf
\f[C]
2015/10/16 bought food
 expenses:food          $10
 assets:cash
\f[R]
.fi
.PP
For more about this format, see hledger_journal(5).
.PP
Most users use a text editor to edit the journal, usually with an editor
mode such as ledger-mode for added convenience.
hledger\[cq]s interactive add command is another way to record new
transactions.
hledger never changes existing transactions.
.PP
To get started, you can either save some entries like the above in
\f[C]\[ti]/.hledger.journal\f[R], or run \f[C]hledger add\f[R] and
follow the prompts.
Then try some commands like \f[C]hledger print\f[R] or
\f[C]hledger balance\f[R].
Run \f[C]hledger\f[R] with no arguments for a list of commands.
.SH COMMON TASKS
.PP
Here are some quick examples of how to do some basic tasks with hledger.
For more details, see the reference section below, the
hledger_journal(5) manual, or the more extensive docs at
https://hledger.org.
.SS Getting help
.IP
.nf
\f[C]
$ hledger                 # show available commands
$ hledger --help          # show common options
$ hledger CMD --help      # show common and command options, and command help
$ hledger help            # show available manuals/topics
$ hledger help hledger    # show hledger manual as info/man/text (auto-chosen)
$ hledger help journal --man  # show the journal manual as a man page
$ hledger help --help     # show more detailed help for the help command
\f[R]
.fi
.PP
Find more docs, chat, mail list, reddit, issue tracker:
https://hledger.org#help-feedback
.SS Constructing command lines
.PP
hledger has an extensive and powerful command line interface.
We strive to keep it simple and ergonomic, but you may run into one of
the confusing real world details described in OPTIONS, below.
If that happens, here are some tips that may help:
.IP \[bu] 2
command-specific options must go after the command (it\[aq]s fine to put
all options there) (\f[C]hledger CMD OPTS ARGS\f[R])
.IP \[bu] 2
running add-on executables directly simplifies command line parsing
(\f[C]hledger-ui OPTS ARGS\f[R])
.IP \[bu] 2
enclose \[dq]problematic\[dq] args in single quotes
.IP \[bu] 2
if needed, also add a backslash to hide regular expression
metacharacters from the shell
.IP \[bu] 2
to see how a misbehaving command is being parsed, add
\f[C]--debug=2\f[R].
.SS Starting a journal file
.PP
hledger looks for your accounting data in a journal file,
\f[C]$HOME/.hledger.journal\f[R] by default:
.IP
.nf
\f[C]
$ hledger stats
The hledger journal file \[dq]/Users/simon/.hledger.journal\[dq] was not found.
Please create it first, eg with \[dq]hledger add\[dq] or a text editor.
Or, specify an existing journal file with -f or LEDGER_FILE.
\f[R]
.fi
.PP
You can override this by setting the \f[C]LEDGER_FILE\f[R] environment
variable.
It\[aq]s a good practice to keep this important file under version
control, and to start a new file each year.
So you could do something like this:
.IP
.nf
\f[C]
$ mkdir \[ti]/finance
$ cd \[ti]/finance
$ git init
Initialized empty Git repository in /Users/simon/finance/.git/
$ touch 2020.journal
$ echo \[dq]export LEDGER_FILE=$HOME/finance/2020.journal\[dq] >> \[ti]/.bashrc
$ source \[ti]/.bashrc
$ hledger stats
Main file                : /Users/simon/finance/2020.journal
Included files           : 
Transactions span        :  to  (0 days)
Last transaction         : none
Transactions             : 0 (0.0 per day)
Transactions last 30 days: 0 (0.0 per day)
Transactions last 7 days : 0 (0.0 per day)
Payees/descriptions      : 0
Accounts                 : 0 (depth 0)
Commodities              : 0 ()
Market prices            : 0 ()
\f[R]
.fi
.SS Setting opening balances
.PP
Pick a starting date for which you can look up the balances of some
real-world assets (bank accounts, wallet..) and liabilities (credit
cards..).
.PP
To avoid a lot of data entry, you may want to start with just one or two
accounts, like your checking account or cash wallet; and pick a recent
starting date, like today or the start of the week.
You can always come back later and add more accounts and older
transactions, eg going back to january 1st.
.PP
Add an opening balances transaction to the journal, declaring the
balances on this date.
Here are two ways to do it:
.IP \[bu] 2
The first way: open the journal in any text editor and save an entry
like this:
.RS 2
.IP
.nf
\f[C]
2020-01-01 * opening balances
    assets:bank:checking                $1000   = $1000
    assets:bank:savings                 $2000   = $2000
    assets:cash                          $100   = $100
    liabilities:creditcard               $-50   = $-50
    equity:opening/closing balances
\f[R]
.fi
.PP
These are start-of-day balances, ie whatever was in the account at the
end of the previous day.
.PP
The * after the date is an optional status flag.
Here it means \[dq]cleared & confirmed\[dq].
.PP
The currency symbols are optional, but usually a good idea as you\[aq]ll
be dealing with multiple currencies sooner or later.
.PP
The = amounts are optional balance assertions, providing extra error
checking.
.RE
.IP \[bu] 2
The second way: run \f[C]hledger add\f[R] and follow the prompts to
record a similar transaction:
.RS 2
.IP
.nf
\f[C]
$ hledger add
Adding transactions to journal file /Users/simon/finance/2020.journal
Any command line arguments will be used as defaults.
Use tab key to complete, readline keys to edit, enter to accept defaults.
An optional (CODE) may follow transaction dates.
An optional ; COMMENT may follow descriptions or amounts.
If you make a mistake, enter < at any prompt to go one step backward.
To end a transaction, enter . when prompted.
To quit, enter . at a date prompt or press control-d or control-c.
Date [2020-02-07]: 2020-01-01
Description: * opening balances
Account 1: assets:bank:checking
Amount  1: $1000
Account 2: assets:bank:savings
Amount  2 [$-1000]: $2000
Account 3: assets:cash
Amount  3 [$-3000]: $100
Account 4: liabilities:creditcard
Amount  4 [$-3100]: $-50
Account 5: equity:opening/closing balances
Amount  5 [$-3050]: 
Account 6 (or . or enter to finish this transaction): .
2020-01-01 * opening balances
    assets:bank:checking                      $1000
    assets:bank:savings                       $2000
    assets:cash                                $100
    liabilities:creditcard                     $-50
    equity:opening/closing balances          $-3050

Save this transaction to the journal ? [y]: 
Saved.
Starting the next transaction (. or ctrl-D/ctrl-C to quit)
Date [2020-01-01]: .
\f[R]
.fi
.RE
.PP
If you\[aq]re using version control, this could be a good time to commit
the journal.
Eg:
.IP
.nf
\f[C]
$ git commit -m \[aq]initial balances\[aq] 2020.journal
\f[R]
.fi
.SS Recording transactions
.PP
As you spend or receive money, you can record these transactions using
one of the methods above (text editor, hledger add) or by using the
hledger-iadd or hledger-web add-ons, or by using the import command to
convert CSV data downloaded from your bank.
.PP
Here are some simple transactions, see the hledger_journal(5) manual and
hledger.org for more ideas:
.IP
.nf
\f[C]
2020/1/10 * gift received
  assets:cash   $20
  income:gifts

2020.1.12 * farmers market
  expenses:food    $13
  assets:cash

2020-01-15 paycheck
  income:salary
  assets:bank:checking    $1000
\f[R]
.fi
.SS Reconciling
.PP
Periodically you should reconcile - compare your hledger-reported
balances against external sources of truth, like bank statements or your
bank\[aq]s website - to be sure that your ledger accurately represents
the real-world balances (and, that the real-world institutions have not
made a mistake!).
This gets easy and fast with (1) practice and (2) frequency.
If you do it daily, it can take 2-10 minutes.
If you let it pile up, expect it to take longer as you hunt down errors
and discrepancies.
.PP
A typical workflow:
.IP "1." 3
Reconcile cash.
Count what\[aq]s in your wallet.
Compare with what hledger reports (\f[C]hledger bal cash\f[R]).
If they are different, try to remember the missing transaction, or look
for the error in the already-recorded transactions.
A register report can be helpful (\f[C]hledger reg cash\f[R]).
If you can\[aq]t find the error, add an adjustment transaction.
Eg if you have $105 after the above, and can\[aq]t explain the missing
$2, it could be:
.RS 4
.IP
.nf
\f[C]
2020-01-16 * adjust cash
    assets:cash    $-2 = $105
    expenses:misc
\f[R]
.fi
.RE
.IP "2." 3
Reconcile checking.
Log in to your bank\[aq]s website.
Compare today\[aq]s (cleared) balance with hledger\[aq]s cleared balance
(\f[C]hledger bal checking -C\f[R]).
If they are different, track down the error or record the missing
transaction(s) or add an adjustment transaction, similar to the above.
Unlike the cash case, you can usually compare the transaction history
and running balance from your bank with the one reported by
\f[C]hledger reg checking -C\f[R].
This will be easier if you generally record transaction dates quite
similar to your bank\[aq]s clearing dates.
.IP "3." 3
Repeat for other asset/liability accounts.
.PP
Tip: instead of the register command, use hledger-ui to see a
live-updating register while you edit the journal:
\f[C]hledger-ui --watch --register checking -C\f[R]
.PP
After reconciling, it could be a good time to mark the reconciled
transactions\[aq] status as \[dq]cleared and confirmed\[dq], if you want
to track that, by adding the \f[C]*\f[R] marker.
Eg in the paycheck transaction above, insert \f[C]*\f[R] between
\f[C]2020-01-15\f[R] and \f[C]paycheck\f[R]
.PP
If you\[aq]re using version control, this can be another good time to
commit:
.IP
.nf
\f[C]
$ git commit -m \[aq]txns\[aq] 2020.journal
\f[R]
.fi
.SS Reporting
.PP
Here are some basic reports.
.PP
Show all transactions:
.IP
.nf
\f[C]
$ hledger print
2020-01-01 * opening balances
    assets:bank:checking                      $1000
    assets:bank:savings                       $2000
    assets:cash                                $100
    liabilities:creditcard                     $-50
    equity:opening/closing balances          $-3050

2020-01-10 * gift received
    assets:cash              $20
    income:gifts

2020-01-12 * farmers market
    expenses:food             $13
    assets:cash

2020-01-15 * paycheck
    income:salary
    assets:bank:checking           $1000

2020-01-16 * adjust cash
    assets:cash               $-2 = $105
    expenses:misc
\f[R]
.fi
.PP
Show account names, and their hierarchy:
.IP
.nf
\f[C]
$ hledger accounts --tree
assets
  bank
    checking
    savings
  cash
equity
  opening/closing balances
expenses
  food
  misc
income
  gifts
  salary
liabilities
  creditcard
\f[R]
.fi
.PP
Show all account totals:
.IP
.nf
\f[C]
$ hledger balance
               $4105  assets
               $4000    bank
               $2000      checking
               $2000      savings
                $105    cash
              $-3050  equity:opening/closing balances
                 $15  expenses
                 $13    food
                  $2    misc
              $-1020  income
                $-20    gifts
              $-1000    salary
                $-50  liabilities:creditcard
--------------------
                   0
\f[R]
.fi
.PP
Show only asset and liability balances, as a flat list, limited to depth
2:
.IP
.nf
\f[C]
$ hledger bal assets liabilities --flat -2
               $4000  assets:bank
                $105  assets:cash
                $-50  liabilities:creditcard
--------------------
               $4055
\f[R]
.fi
.PP
Show the same thing without negative numbers, formatted as a simple
balance sheet:
.IP
.nf
\f[C]
$ hledger bs --flat -2
Balance Sheet 2020-01-16

                        || 2020-01-16 
========================++============
 Assets                 ||            
------------------------++------------
 assets:bank            ||      $4000 
 assets:cash            ||       $105 
------------------------++------------
                        ||      $4105 
========================++============
 Liabilities            ||            
------------------------++------------
 liabilities:creditcard ||        $50 
------------------------++------------
                        ||        $50 
========================++============
 Net:                   ||      $4055 
\f[R]
.fi
.PP
The final total is your \[dq]net worth\[dq] on the end date.
(Or use \f[C]bse\f[R] for a full balance sheet with equity.)
.PP
Show income and expense totals, formatted as an income statement:
.IP
.nf
\f[C]
hledger is 
Income Statement 2020-01-01-2020-01-16

               || 2020-01-01-2020-01-16 
===============++=======================
 Revenues      ||                       
---------------++-----------------------
 income:gifts  ||                   $20 
 income:salary ||                 $1000 
---------------++-----------------------
               ||                 $1020 
===============++=======================
 Expenses      ||                       
---------------++-----------------------
 expenses:food ||                   $13 
 expenses:misc ||                    $2 
---------------++-----------------------
               ||                   $15 
===============++=======================
 Net:          ||                 $1005 
\f[R]
.fi
.PP
The final total is your net income during this period.
.PP
Show transactions affecting your wallet, with running total:
.IP
.nf
\f[C]
$ hledger register cash
2020-01-01 opening balances     assets:cash                   $100          $100
2020-01-10 gift received        assets:cash                    $20          $120
2020-01-12 farmers market       assets:cash                   $-13          $107
2020-01-16 adjust cash          assets:cash                    $-2          $105
\f[R]
.fi
.PP
Show weekly posting counts as a bar chart:
.IP
.nf
\f[C]
$ hledger activity -W
2019-12-30 *****
2020-01-06 ****
2020-01-13 ****
\f[R]
.fi
.SS Migrating to a new file
.PP
At the end of the year, you may want to continue your journal in a new
file, so that old transactions don\[aq]t slow down or clutter your
reports, and to help ensure the integrity of your accounting history.
See the close command.
.PP
If using version control, don\[aq]t forget to \f[C]git add\f[R] the new
file.
.SH OPTIONS
.SS General options
.PP
To see general usage help, including general options which are supported
by most hledger commands, run \f[C]hledger -h\f[R].
.PP
General help options:
.TP
\f[B]\f[CB]-h --help\f[B]\f[R]
show general usage (or after COMMAND, command usage)
.TP
\f[B]\f[CB]--version\f[B]\f[R]
show version
.TP
\f[B]\f[CB]--debug[=N]\f[B]\f[R]
show debug output (levels 1-9, default: 1)
.PP
General input options:
.TP
\f[B]\f[CB]-f FILE --file=FILE\f[B]\f[R]
use a different input file.
For stdin, use - (default: \f[C]$LEDGER_FILE\f[R] or
\f[C]$HOME/.hledger.journal\f[R])
.TP
\f[B]\f[CB]--rules-file=RULESFILE\f[B]\f[R]
Conversion rules file to use when reading CSV (default: FILE.rules)
.TP
\f[B]\f[CB]--separator=CHAR\f[B]\f[R]
Field separator to expect when reading CSV (default: \[aq],\[aq])
.TP
\f[B]\f[CB]--alias=OLD=NEW\f[B]\f[R]
rename accounts named OLD to NEW
.TP
\f[B]\f[CB]--anon\f[B]\f[R]
anonymize accounts and payees
.TP
\f[B]\f[CB]--pivot FIELDNAME\f[B]\f[R]
use some other field or tag for the account name
.TP
\f[B]\f[CB]-I --ignore-assertions\f[B]\f[R]
disable balance assertion checks (note: does not disable balance
assignments)
.PP
General reporting options:
.TP
\f[B]\f[CB]-b --begin=DATE\f[B]\f[R]
include postings/txns on or after this date
.TP
\f[B]\f[CB]-e --end=DATE\f[B]\f[R]
include postings/txns before this date
.TP
\f[B]\f[CB]-D --daily\f[B]\f[R]
multiperiod/multicolumn report by day
.TP
\f[B]\f[CB]-W --weekly\f[B]\f[R]
multiperiod/multicolumn report by week
.TP
\f[B]\f[CB]-M --monthly\f[B]\f[R]
multiperiod/multicolumn report by month
.TP
\f[B]\f[CB]-Q --quarterly\f[B]\f[R]
multiperiod/multicolumn report by quarter
.TP
\f[B]\f[CB]-Y --yearly\f[B]\f[R]
multiperiod/multicolumn report by year
.TP
\f[B]\f[CB]-p --period=PERIODEXP\f[B]\f[R]
set start date, end date, and/or reporting interval all at once using
period expressions syntax
.TP
\f[B]\f[CB]--date2\f[B]\f[R]
match the secondary date instead (see command help for other effects)
.TP
\f[B]\f[CB]-U --unmarked\f[B]\f[R]
include only unmarked postings/txns (can combine with -P or -C)
.TP
\f[B]\f[CB]-P --pending\f[B]\f[R]
include only pending postings/txns
.TP
\f[B]\f[CB]-C --cleared\f[B]\f[R]
include only cleared postings/txns
.TP
\f[B]\f[CB]-R --real\f[B]\f[R]
include only non-virtual postings
.TP
\f[B]\f[CB]-NUM --depth=NUM\f[B]\f[R]
hide/aggregate accounts or postings more than NUM levels deep
.TP
\f[B]\f[CB]-E --empty\f[B]\f[R]
show items with zero amount, normally hidden (and vice-versa in
hledger-ui/hledger-web)
.TP
\f[B]\f[CB]-B --cost\f[B]\f[R]
convert amounts to their cost at transaction time (using the transaction
price, if any)
.TP
\f[B]\f[CB]-V --value\f[B]\f[R]
convert amounts to their market value on the report end date (using the
most recent applicable market price, if any)
.TP
\f[B]\f[CB]--auto\f[B]\f[R]
apply automated posting rules to modify transactions.
.TP
\f[B]\f[CB]--forecast\f[B]\f[R]
generate future transactions from periodic transaction rules, for the
next 6 months or till report end date.
In hledger-ui, also make ordinary future transactions visible.
.PP
When a reporting option appears more than once in the command line, the
last one takes precedence.
.PP
Some reporting options can also be written as query arguments.
.SS Command options
.PP
To see options for a particular command, including command-specific
options, run: \f[C]hledger COMMAND -h\f[R].
.PP
Command-specific options must be written after the command name, eg:
\f[C]hledger print -x\f[R].
.PP
Additionally, if the command is an addon, you may need to put its
options after a double-hyphen, eg: \f[C]hledger ui -- --watch\f[R].
Or, you can run the addon executable directly:
\f[C]hledger-ui --watch\f[R].
.SS Command arguments
.PP
Most hledger commands accept arguments after the command name, which are
often a query, filtering the data in some way.
.PP
You can save a set of command line options/arguments in a file, and then
reuse them by writing \f[C]\[at]FILENAME\f[R] as a command line
argument.
Eg: \f[C]hledger bal \[at]foo.args\f[R].
(To prevent this, eg if you have an argument that begins with a literal
\f[C]\[at]\f[R], precede it with \f[C]--\f[R], eg:
\f[C]hledger bal -- \[at]ARG\f[R]).
.PP
Inside the argument file, each line should contain just one option or
argument.
Avoid the use of spaces, except inside quotes (or you\[aq]ll see a
confusing error).
Between a flag and its argument, use = (or nothing).
Bad:
.IP
.nf
\f[C]
assets depth:2
-X USD
\f[R]
.fi
.PP
Good:
.IP
.nf
\f[C]
assets
depth:2
-X=USD
\f[R]
.fi
.PP
For special characters (see below), use one less level of quoting than
you would at the command prompt.
Bad:
.IP
.nf
\f[C]
-X\[dq]$\[dq]
\f[R]
.fi
.PP
Good:
.IP
.nf
\f[C]
-X$
\f[R]
.fi
.PP
See also: Save frequently used options.
.SS Queries
.PP
One of hledger\[aq]s strengths is being able to quickly report on
precise subsets of your data.
Most commands accept an optional query expression, written as arguments
after the command name, to filter the data by date, account name or
other criteria.
The syntax is similar to a web search: one or more space-separated
search terms, quotes to enclose whitespace, prefixes to match specific
fields, a not: prefix to negate the match.
.PP
We do not yet support arbitrary boolean combinations of search terms;
instead most commands show transactions/postings/accounts which match
(or negatively match):
.IP \[bu] 2
any of the description terms AND
.IP \[bu] 2
any of the account terms AND
.IP \[bu] 2
any of the status terms AND
.IP \[bu] 2
all the other terms.
.PP
The print command instead shows transactions which:
.IP \[bu] 2
match any of the description terms AND
.IP \[bu] 2
have any postings matching any of the positive account terms AND
.IP \[bu] 2
have no postings matching any of the negative account terms AND
.IP \[bu] 2
match all the other terms.
.PP
The following kinds of search terms can be used.
Remember these can also be prefixed with \f[B]\f[CB]not:\f[B]\f[R], eg
to exclude a particular subaccount.
.TP
\f[B]\f[R]\f[C]REGEX\f[R]\f[B], \f[R]\f[C]acct:REGEX\f[R]\f[B]\f[R]
match account names by this regular expression.
(With no prefix, \f[C]acct:\f[R] is assumed.)
same as above
.TP
\f[B]\f[R]\f[C]amt:N, amt:<N, amt:<=N, amt:>N, amt:>=N\f[R]\f[B]\f[R]
match postings with a single-commodity amount that is equal to, less
than, or greater than N.
(Multi-commodity amounts are not tested, and will always match.) The
comparison has two modes: if N is preceded by a + or - sign (or is 0),
the two signed numbers are compared.
Otherwise, the absolute magnitudes are compared, ignoring sign.
.TP
\f[B]\f[R]\f[C]code:REGEX\f[R]\f[B]\f[R]
match by transaction code (eg check number)
.TP
\f[B]\f[R]\f[C]cur:REGEX\f[R]\f[B]\f[R]
match postings or transactions including any amounts whose
currency/commodity symbol is fully matched by REGEX.
(For a partial match, use \f[C].*REGEX.*\f[R]).
Note, to match characters which are regex-significant, like the dollar
sign (\f[C]$\f[R]), you need to prepend \f[C]\[rs]\f[R].
And when using the command line you need to add one more level of
quoting to hide it from the shell, so eg do:
\f[C]hledger print cur:\[aq]\[rs]$\[aq]\f[R] or
\f[C]hledger print cur:\[rs]\[rs]$\f[R].
.TP
\f[B]\f[R]\f[C]desc:REGEX\f[R]\f[B]\f[R]
match transaction descriptions.
.TP
\f[B]\f[R]\f[C]date:PERIODEXPR\f[R]\f[B]\f[R]
match dates within the specified period.
PERIODEXPR is a period expression (with no report interval).
Examples: \f[C]date:2016\f[R], \f[C]date:thismonth\f[R],
\f[C]date:2000/2/1-2/15\f[R], \f[C]date:lastweek-\f[R].
If the \f[C]--date2\f[R] command line flag is present, this matches
secondary dates instead.
.TP
\f[B]\f[R]\f[C]date2:PERIODEXPR\f[R]\f[B]\f[R]
match secondary dates within the specified period.
.TP
\f[B]\f[R]\f[C]depth:N\f[R]\f[B]\f[R]
match (or display, depending on command) accounts at or above this depth
.TP
\f[B]\f[R]\f[C]note:REGEX\f[R]\f[B]\f[R]
match transaction notes (part of description right of \f[C]|\f[R], or
whole description when there\[aq]s no \f[C]|\f[R])
.TP
\f[B]\f[R]\f[C]payee:REGEX\f[R]\f[B]\f[R]
match transaction payee/payer names (part of description left of
\f[C]|\f[R], or whole description when there\[aq]s no \f[C]|\f[R])
.TP
\f[B]\f[R]\f[C]real:, real:0\f[R]\f[B]\f[R]
match real or virtual postings respectively
.TP
\f[B]\f[R]\f[C]status:, status:!, status:*\f[R]\f[B]\f[R]
match unmarked, pending, or cleared transactions respectively
.TP
\f[B]\f[R]\f[C]tag:REGEX[=REGEX]\f[R]\f[B]\f[R]
match by tag name, and optionally also by tag value.
Note a tag: query is considered to match a transaction if it matches any
of the postings.
Also remember that postings inherit the tags of their parent
transaction.
.PP
The following special search term is used automatically in hledger-web,
only:
.TP
\f[B]\f[R]\f[C]inacct:ACCTNAME\f[R]\f[B]\f[R]
tells hledger-web to show the transaction register for this account.
Can be filtered further with \f[C]acct\f[R] etc.
.PP
Some of these can also be expressed as command-line options (eg
\f[C]depth:2\f[R] is equivalent to \f[C]--depth 2\f[R]).
Generally you can mix options and query arguments, and the resulting
query will be their intersection (perhaps excluding the
\f[C]-p/--period\f[R] option).
.SS Special characters in arguments and queries
.PP
In shell command lines, option and argument values which contain
\[dq]problematic\[dq] characters, ie spaces, and also characters
significant to your shell such as \f[C]<\f[R], \f[C]>\f[R], \f[C](\f[R],
\f[C])\f[R], \f[C]|\f[R] and \f[C]$\f[R], should be escaped by enclosing
them in quotes or by writing backslashes before the characters.
Eg:
.PP
\f[C]hledger register -p \[aq]last year\[aq] \[dq]accounts receivable (receivable|payable)\[dq] amt:\[rs]>100\f[R].
.SS More escaping
.PP
Characters significant both to the shell and in regular expressions may
need one extra level of escaping.
These include parentheses, the pipe symbol and the dollar sign.
Eg, to match the dollar symbol, bash users should do:
.PP
\f[C]hledger balance cur:\[aq]\[rs]$\[aq]\f[R]
.PP
or:
.PP
\f[C]hledger balance cur:\[rs]\[rs]$\f[R]
.SS Even more escaping
.PP
When hledger runs an addon executable (eg you type \f[C]hledger ui\f[R],
hledger runs \f[C]hledger-ui\f[R]), it de-escapes command-line options
and arguments once, so you might need to \f[I]triple\f[R]-escape.
Eg in bash, running the ui command and matching the dollar sign,
it\[aq]s:
.PP
\f[C]hledger ui cur:\[aq]\[rs]\[rs]$\[aq]\f[R]
.PP
or:
.PP
\f[C]hledger ui cur:\[rs]\[rs]\[rs]\[rs]$\f[R]
.PP
If you asked why \f[I]four\f[R] slashes above, this may help:
.PP
.TS
tab(@);
l l.
T{
unescaped:
T}@T{
\f[C]$\f[R]
T}
T{
escaped:
T}@T{
\f[C]\[rs]$\f[R]
T}
T{
double-escaped:
T}@T{
\f[C]\[rs]\[rs]$\f[R]
T}
T{
triple-escaped:
T}@T{
\f[C]\[rs]\[rs]\[rs]\[rs]$\f[R]
T}
.TE
.PP
(The number of backslashes in fish shell is left as an exercise for the
reader.)
.PP
You can always avoid the extra escaping for addons by running the addon
directly:
.PP
\f[C]hledger-ui cur:\[rs]\[rs]$\f[R]
.SS Less escaping
.PP
Inside an argument file, or in the search field of hledger-ui or
hledger-web, or at a GHCI prompt, you need one less level of escaping
than at the command line.
And backslashes may work better than quotes.
Eg:
.PP
\f[C]ghci> :main balance cur:\[rs]$\f[R]
.SS Unicode characters
.PP
hledger is expected to handle non-ascii characters correctly:
.IP \[bu] 2
they should be parsed correctly in input files and on the command line,
by all hledger tools (add, iadd, hledger-web\[aq]s search/add/edit
forms, etc.)
.IP \[bu] 2
they should be displayed correctly by all hledger tools, and on-screen
alignment should be preserved.
.PP
This requires a well-configured environment.
Here are some tips:
.IP \[bu] 2
A system locale must be configured, and it must be one that can decode
the characters being used.
In bash, you can set a locale like this:
\f[C]export LANG=en_US.UTF-8\f[R].
There are some more details in Troubleshooting.
This step is essential - without it, hledger will quit on encountering a
non-ascii character (as with all GHC-compiled programs).
.IP \[bu] 2
your terminal software (eg Terminal.app, iTerm, CMD.exe, xterm..) must
support unicode
.IP \[bu] 2
the terminal must be using a font which includes the required unicode
glyphs
.IP \[bu] 2
the terminal should be configured to display wide characters as double
width (for report alignment)
.IP \[bu] 2
on Windows, for best results you should run hledger in the same kind of
environment in which it was built.
Eg hledger built in the standard CMD.EXE environment (like the binaries
on our download page) might show display problems when run in a cygwin
or msys terminal, and vice versa.
(See eg #961).
.SS Input files
.PP
hledger reads transactions from a data file (and the add command writes
to it).
By default this file is \f[C]$HOME/.hledger.journal\f[R] (or on Windows,
something like \f[C]C:/Users/USER/.hledger.journal\f[R]).
You can override this with the \f[C]$LEDGER_FILE\f[R] environment
variable:
.IP
.nf
\f[C]
$ setenv LEDGER_FILE \[ti]/finance/2016.journal
$ hledger stats
\f[R]
.fi
.PP
or with the \f[C]-f/--file\f[R] option:
.IP
.nf
\f[C]
$ hledger -f /some/file stats
\f[R]
.fi
.PP
The file name \f[C]-\f[R] (hyphen) means standard input:
.IP
.nf
\f[C]
$ cat some.journal | hledger -f-
\f[R]
.fi
.PP
Usually the data file is in hledger\[aq]s journal format, but it can
also be one of several other formats, listed below.
hledger detects the format automatically based on the file extension, or
if that is not recognised, by trying each built-in \[dq]reader\[dq] in
turn:
.PP
.TS
tab(@);
lw(7.6n) lw(31.2n) lw(31.2n).
T{
Reader:
T}@T{
Reads:
T}@T{
Used for file extensions:
T}
_
T{
\f[C]journal\f[R]
T}@T{
hledger\[aq]s journal format, also some Ledger journals
T}@T{
\f[C].journal\f[R] \f[C].j\f[R] \f[C].hledger\f[R] \f[C].ledger\f[R]
T}
T{
\f[C]timeclock\f[R]
T}@T{
timeclock files (precise time logging)
T}@T{
\f[C].timeclock\f[R]
T}
T{
\f[C]timedot\f[R]
T}@T{
timedot files (approximate time logging)
T}@T{
\f[C].timedot\f[R]
T}
T{
\f[C]csv\f[R]
T}@T{
comma-separated values (data interchange)
T}@T{
\f[C].csv\f[R]
T}
.TE
.PP
If needed (eg to ensure correct error messages when a file has the
\[dq]wrong\[dq] extension), you can force a specific reader/format by
prepending it to the file path with a colon.
Examples:
.IP
.nf
\f[C]
$ hledger -f csv:/some/csv-file.dat stats
$ echo \[aq]i 2009/13/1 08:00:00\[aq] | hledger print -ftimeclock:-
\f[R]
.fi
.PP
You can also specify multiple \f[C]-f\f[R] options, to read multiple
files as one big journal.
There are some limitations with this:
.IP \[bu] 2
directives in one file will not affect the other files
.IP \[bu] 2
balance assertions will not see any account balances from previous files
.PP
If you need those, either use the include directive, or concatenate the
files, eg: \f[C]cat a.journal b.journal | hledger -f- CMD\f[R].
.SS Output destination
.PP
hledger commands send their output to the terminal by default.
You can of course redirect this, eg into a file, using standard shell
syntax:
.IP
.nf
\f[C]
$ hledger print > foo.txt
\f[R]
.fi
.PP
Some commands (print, register, stats, the balance commands) also
provide the \f[C]-o/--output-file\f[R] option, which does the same thing
without needing the shell.
Eg:
.IP
.nf
\f[C]
$ hledger print -o foo.txt
$ hledger print -o -        # write to stdout (the default)
\f[R]
.fi
.SS Output format
.PP
Some commands (print, register, the balance commands) offer a choice of
output format.
In addition to the usual plain text format (\f[C]txt\f[R]), there are
CSV (\f[C]csv\f[R]), HTML (\f[C]html\f[R]) and JSON (\f[C]json\f[R]).
This is controlled by the \f[C]-O/--output-format\f[R] option:
.IP
.nf
\f[C]
$ hledger print -O csv
\f[R]
.fi
.PP
or, by a file extension specified with \f[C]-o/--output-file\f[R]:
.IP
.nf
\f[C]
$ hledger balancesheet -o foo.html   # write HTML to foo.html
\f[R]
.fi
.PP
The \f[C]-O\f[R] option can be used to override the file extension if
needed:
.IP
.nf
\f[C]
$ hledger balancesheet -o foo.txt -O html   # write HTML to foo.txt
\f[R]
.fi
.PP
Some notes about JSON output:
.IP \[bu] 2
This feature is marked experimental, and not yet much used; you should
expect our JSON to evolve.
Real-world feedback is welcome.
.IP \[bu] 2
Our JSON is rather large and verbose, as it is quite a faithful
representation of hledger\[aq]s internal data types.
To understand the JSON, read the Haskell type definitions, which are
mostly in
https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Data/Types.hs.
.IP \[bu] 2
hledger represents quantities as Decimal values storing up to 255
significant digits, eg for repeating decimals.
Such numbers can arise in practice (from automatically-calculated
transaction prices), and would break most JSON consumers.
So in JSON, we show quantities as simple Numbers with at most 10 decimal
places.
We don\[aq]t limit the number of integer digits, but that part is under
your control.
We hope this approach will not cause problems in practice; if you find
otherwise, please let us know.
(Cf #1195)
.SS Regular expressions
.PP
hledger uses regular expressions in a number of places:
.IP \[bu] 2
query terms, on the command line and in the hledger-web search form:
\f[C]REGEX\f[R], \f[C]desc:REGEX\f[R], \f[C]cur:REGEX\f[R],
\f[C]tag:...=REGEX\f[R]
.IP \[bu] 2
CSV rules conditional blocks: \f[C]if REGEX ...\f[R]
.IP \[bu] 2
account alias directives and options:
\f[C]alias /REGEX/ = REPLACEMENT\f[R],
\f[C]--alias /REGEX/=REPLACEMENT\f[R]
.PP
hledger\[aq]s regular expressions come from the regex-tdfa library.
If they\[aq]re not doing what you expect, it\[aq]s important to know
exactly what they support:
.IP "1." 3
they are case insensitive
.IP "2." 3
they are infix matching (they do not need to match the entire thing
being matched)
.IP "3." 3
they are POSIX ERE (extended regular expressions)
.IP "4." 3
they also support GNU word boundaries (\f[C]\[rs]b\f[R],
\f[C]\[rs]B\f[R], \f[C]\[rs]<\f[R], \f[C]\[rs]>\f[R])
.IP "5." 3
they do not support backreferences; if you write \f[C]\[rs]1\f[R], it
will match the digit \f[C]1\f[R].
Except when doing text replacement, eg in account aliases, where
backreferences can be used in the replacement string to reference
capturing groups in the search regexp.
.IP "6." 3
they do not support mode modifiers (\f[C](?s)\f[R]), character classes
(\f[C]\[rs]w\f[R], \f[C]\[rs]d\f[R]), or anything else not mentioned
above.
.PP
Some things to note:
.IP \[bu] 2
In the \f[C]alias\f[R] directive and \f[C]--alias\f[R] option, regular
expressions must be enclosed in forward slashes (\f[C]/REGEX/\f[R]).
Elsewhere in hledger, these are not required.
.IP \[bu] 2
In queries, to match a regular expression metacharacter like \f[C]$\f[R]
as a literal character, prepend a backslash.
Eg to search for amounts with the dollar sign in hledger-web, write
\f[C]cur:\[rs]$\f[R].
.IP \[bu] 2
On the command line, some metacharacters like \f[C]$\f[R] have a special
meaning to the shell and so must be escaped at least once more.
See Special characters.
.SS Smart dates
.PP
hledger\[aq]s user interfaces accept a flexible \[dq]smart date\[dq]
syntax (unlike dates in the journal file).
Smart dates allow some english words, can be relative to today\[aq]s
date, and can have less-significant date parts omitted (defaulting to
1).
.PP
Examples:
.PP
.TS
tab(@);
lw(24.2n) lw(45.8n).
T{
\f[C]2004/10/1\f[R], \f[C]2004-01-01\f[R], \f[C]2004.9.1\f[R]
T}@T{
exact date, several separators allowed.
Year is 4+ digits, month is 1-12, day is 1-31
T}
T{
\f[C]2004\f[R]
T}@T{
start of year
T}
T{
\f[C]2004/10\f[R]
T}@T{
start of month
T}
T{
\f[C]10/1\f[R]
T}@T{
month and day in current year
T}
T{
\f[C]21\f[R]
T}@T{
day in current month
T}
T{
\f[C]october, oct\f[R]
T}@T{
start of month in current year
T}
T{
\f[C]yesterday, today, tomorrow\f[R]
T}@T{
-1, 0, 1 days from today
T}
T{
\f[C]last/this/next day/week/month/quarter/year\f[R]
T}@T{
-1, 0, 1 periods from the current period
T}
T{
\f[C]20181201\f[R]
T}@T{
8 digit YYYYMMDD with valid year month and day
T}
T{
\f[C]201812\f[R]
T}@T{
6 digit YYYYMM with valid year and month
T}
.TE
.PP
Counterexamples - malformed digit sequences might give surprising
results:
.PP
.TS
tab(@);
lw(11.4n) lw(58.6n).
T{
\f[C]201813\f[R]
T}@T{
6 digits with an invalid month is parsed as start of 6-digit year
T}
T{
\f[C]20181301\f[R]
T}@T{
8 digits with an invalid month is parsed as start of 8-digit year
T}
T{
\f[C]20181232\f[R]
T}@T{
8 digits with an invalid day gives an error
T}
T{
\f[C]201801012\f[R]
T}@T{
9+ digits beginning with a valid YYYYMMDD gives an error
T}
.TE
.SS Report start & end date
.PP
Most hledger reports show the full span of time represented by the
journal data, by default.
So, the effective report start and end dates will be the earliest and
latest transaction or posting dates found in the journal.
.PP
Often you will want to see a shorter time span, such as the current
month.
You can specify a start and/or end date using \f[C]-b/--begin\f[R],
\f[C]-e/--end\f[R], \f[C]-p/--period\f[R] or a \f[C]date:\f[R] query
(described below).
All of these accept the smart date syntax.
.PP
Some notes:
.IP \[bu] 2
As in Ledger, end dates are exclusive, so you need to write the date
\f[I]after\f[R] the last day you want to include.
.IP \[bu] 2
As noted in reporting options: among start/end dates specified with
\f[I]options\f[R], the last (i.e.
right-most) option takes precedence.
.IP \[bu] 2
The effective report start and end dates are the intersection of the
start/end dates from options and that from \f[C]date:\f[R] queries.
That is, \f[C]date:2019-01 date:2019 -p\[aq]2000 to 2030\[aq]\f[R]
yields January 2019, the smallest common time span.
.PP
Examples:
.PP
.TS
tab(@);
lw(12.4n) lw(57.6n).
T{
\f[C]-b 2016/3/17\f[R]
T}@T{
begin on St.\ Patrick\[cq]s day 2016
T}
T{
\f[C]-e 12/1\f[R]
T}@T{
end at the start of december 1st of the current year (11/30 will be the
last date included)
T}
T{
\f[C]-b thismonth\f[R]
T}@T{
all transactions on or after the 1st of the current month
T}
T{
\f[C]-p thismonth\f[R]
T}@T{
all transactions in the current month
T}
T{
\f[C]date:2016/3/17..\f[R]
T}@T{
the above written as queries instead (\f[C]..\f[R] can also be replaced
with \f[C]-\f[R])
T}
T{
\f[C]date:..12/1\f[R]
T}@T{
T}
T{
\f[C]date:thismonth..\f[R]
T}@T{
T}
T{
\f[C]date:thismonth\f[R]
T}@T{
T}
.TE
.SS Report intervals
.PP
A report interval can be specified so that commands like register,
balance and activity will divide their reports into multiple subperiods.
The basic intervals can be selected with one of \f[C]-D/--daily\f[R],
\f[C]-W/--weekly\f[R], \f[C]-M/--monthly\f[R], \f[C]-Q/--quarterly\f[R],
or \f[C]-Y/--yearly\f[R].
More complex intervals may be specified with a period expression.
Report intervals can not be specified with a query.
.SS Period expressions
.PP
The \f[C]-p/--period\f[R] option accepts period expressions, a shorthand
way of expressing a start date, end date, and/or report interval all at
once.
.PP
Here\[aq]s a basic period expression specifying the first quarter of
2009.
Note, hledger always treats start dates as inclusive and end dates as
exclusive:
.PP
\f[C]-p \[dq]from 2009/1/1 to 2009/4/1\[dq]\f[R]
.PP
Keywords like \[dq]from\[dq] and \[dq]to\[dq] are optional, and so are
the spaces, as long as you don\[aq]t run two dates together.
\[dq]to\[dq] can also be written as \[dq]..\[dq] or \[dq]-\[dq].
These are equivalent to the above:
.PP
.TS
tab(@);
l.
T{
\f[C]-p \[dq]2009/1/1 2009/4/1\[dq]\f[R]
T}
T{
\f[C]-p2009/1/1to2009/4/1\f[R]
T}
T{
\f[C]-p2009/1/1..2009/4/1\f[R]
T}
.TE
.PP
Dates are smart dates, so if the current year is 2009, the above can
also be written as:
.PP
.TS
tab(@);
l.
T{
\f[C]-p \[dq]1/1 4/1\[dq]\f[R]
T}
T{
\f[C]-p \[dq]january-apr\[dq]\f[R]
T}
T{
\f[C]-p \[dq]this year to 4/1\[dq]\f[R]
T}
.TE
.PP
If you specify only one date, the missing start or end date will be the
earliest or latest transaction in your journal:
.PP
.TS
tab(@);
l l.
T{
\f[C]-p \[dq]from 2009/1/1\[dq]\f[R]
T}@T{
everything after january 1, 2009
T}
T{
\f[C]-p \[dq]from 2009/1\[dq]\f[R]
T}@T{
the same
T}
T{
\f[C]-p \[dq]from 2009\[dq]\f[R]
T}@T{
the same
T}
T{
\f[C]-p \[dq]to 2009\[dq]\f[R]
T}@T{
everything before january 1, 2009
T}
.TE
.PP
A single date with no \[dq]from\[dq] or \[dq]to\[dq] defines both the
start and end date like so:
.PP
.TS
tab(@);
l l.
T{
\f[C]-p \[dq]2009\[dq]\f[R]
T}@T{
the year 2009; equivalent to \[lq]2009/1/1 to 2010/1/1\[rq]
T}
T{
\f[C]-p \[dq]2009/1\[dq]\f[R]
T}@T{
the month of jan; equivalent to \[lq]2009/1/1 to 2009/2/1\[rq]
T}
T{
\f[C]-p \[dq]2009/1/1\[dq]\f[R]
T}@T{
just that day; equivalent to \[lq]2009/1/1 to 2009/1/2\[rq]
T}
.TE
.PP
The argument of \f[C]-p\f[R] can also begin with, or be, a report
interval expression.
The basic report intervals are \f[C]daily\f[R], \f[C]weekly\f[R],
\f[C]monthly\f[R], \f[C]quarterly\f[R], or \f[C]yearly\f[R], which have
the same effect as the
\f[C]-D\f[R],\f[C]-W\f[R],\f[C]-M\f[R],\f[C]-Q\f[R], or \f[C]-Y\f[R]
flags.
Between report interval and start/end dates (if any), the word
\f[C]in\f[R] is optional.
Examples:
.PP
.TS
tab(@);
l.
T{
\f[C]-p \[dq]weekly from 2009/1/1 to 2009/4/1\[dq]\f[R]
T}
T{
\f[C]-p \[dq]monthly in 2008\[dq]\f[R]
T}
T{
\f[C]-p \[dq]quarterly\[dq]\f[R]
T}
.TE
.PP
Note that \f[C]weekly\f[R], \f[C]monthly\f[R], \f[C]quarterly\f[R] and
\f[C]yearly\f[R] intervals will always start on the first day on week,
month, quarter or year accordingly, and will end on the last day of same
period, even if associated period expression specifies different
explicit start and end date.
.PP
For example:
.PP
.TS
tab(@);
lw(25.5n) lw(44.5n).
T{
\f[C]-p \[dq]weekly from 2009/1/1 to 2009/4/1\[dq]\f[R]
T}@T{
starts on 2008/12/29, closest preceding Monday
T}
T{
\f[C]-p \[dq]monthly in 2008/11/25\[dq]\f[R]
T}@T{
starts on 2018/11/01
T}
T{
\f[C]-p \[dq]quarterly from 2009-05-05 to 2009-06-01\[dq]\f[R]
T}@T{
starts on 2009/04/01, ends on 2009/06/30, which are first and last days
of Q2 2009
T}
T{
\f[C]-p \[dq]yearly from 2009-12-29\[dq]\f[R]
T}@T{
starts on 2009/01/01, first day of 2009
T}
.TE
.PP
The following more complex report intervals are also supported:
\f[C]biweekly\f[R], \f[C]bimonthly\f[R],
\f[C]every day|week|month|quarter|year\f[R],
\f[C]every N days|weeks|months|quarters|years\f[R].
.PP
All of these will start on the first day of the requested period and end
on the last one, as described above.
.PP
Examples:
.PP
.TS
tab(@);
lw(25.5n) lw(44.5n).
T{
\f[C]-p \[dq]bimonthly from 2008\[dq]\f[R]
T}@T{
periods will have boundaries on 2008/01/01, 2008/03/01, ...
T}
T{
\f[C]-p \[dq]every 2 weeks\[dq]\f[R]
T}@T{
starts on closest preceding Monday
T}
T{
\f[C]-p \[dq]every 5 month from 2009/03\[dq]\f[R]
T}@T{
periods will have boundaries on 2009/03/01, 2009/08/01, ...
T}
.TE
.PP
If you want intervals that start on arbitrary day of your choosing and
span a week, month or year, you need to use any of the following:
.PP
\f[C]every Nth day of week\f[R], \f[C]every <weekday>\f[R],
\f[C]every Nth day [of month]\f[R],
\f[C]every Nth weekday [of month]\f[R], \f[C]every MM/DD [of year]\f[R],
\f[C]every Nth MMM [of year]\f[R], \f[C]every MMM Nth [of year]\f[R].
.PP
Examples:
.PP
.TS
tab(@);
lw(23.9n) lw(46.1n).
T{
\f[C]-p \[dq]every 2nd day of week\[dq]\f[R]
T}@T{
periods will go from Tue to Tue
T}
T{
\f[C]-p \[dq]every Tue\[dq]\f[R]
T}@T{
same
T}
T{
\f[C]-p \[dq]every 15th day\[dq]\f[R]
T}@T{
period boundaries will be on 15th of each month
T}
T{
\f[C]-p \[dq]every 2nd Monday\[dq]\f[R]
T}@T{
period boundaries will be on second Monday of each month
T}
T{
\f[C]-p \[dq]every 11/05\[dq]\f[R]
T}@T{
yearly periods with boundaries on 5th of Nov
T}
T{
\f[C]-p \[dq]every 5th Nov\[dq]\f[R]
T}@T{
same
T}
T{
\f[C]-p \[dq]every Nov 5th\[dq]\f[R]
T}@T{
same
T}
.TE
.PP
Show historical balances at end of 15th each month (N is exclusive end
date):
.PP
\f[C]hledger balance -H -p \[dq]every 16th day\[dq]\f[R]
.PP
Group postings from start of wednesday to end of next tuesday (N is
start date and exclusive end date):
.PP
\f[C]hledger register checking -p \[dq]every 3rd day of week\[dq]\f[R]
.SS Depth limiting
.PP
With the \f[C]--depth N\f[R] option (short form: \f[C]-N\f[R]), commands
like account, balance and register will show only the uppermost accounts
in the account tree, down to level N.
Use this when you want a summary with less detail.
This flag has the same effect as a \f[C]depth:\f[R] query argument (so
\f[C]-2\f[R], \f[C]--depth=2\f[R] or \f[C]depth:2\f[R] are equivalent).
.SS Pivoting
.PP
Normally hledger sums amounts, and organizes them in a hierarchy, based
on account name.
The \f[C]--pivot FIELD\f[R] option causes it to sum and organize
hierarchy based on the value of some other field instead.
FIELD can be: \f[C]code\f[R], \f[C]description\f[R], \f[C]payee\f[R],
\f[C]note\f[R], or the full name (case insensitive) of any tag.
As with account names, values containing \f[C]colon:separated:parts\f[R]
will be displayed hierarchically in reports.
.PP
\f[C]--pivot\f[R] is a general option affecting all reports; you can
think of hledger transforming the journal before any other processing,
replacing every posting\[aq]s account name with the value of the
specified field on that posting, inheriting it from the transaction or
using a blank value if it\[aq]s not present.
.PP
An example:
.IP
.nf
\f[C]
2016/02/16 Member Fee Payment
    assets:bank account                    2 EUR
    income:member fees                    -2 EUR  ; member: John Doe
\f[R]
.fi
.PP
Normal balance report showing account names:
.IP
.nf
\f[C]
$ hledger balance
               2 EUR  assets:bank account
              -2 EUR  income:member fees
--------------------
                   0
\f[R]
.fi
.PP
Pivoted balance report, using member: tag values instead:
.IP
.nf
\f[C]
$ hledger balance --pivot member
               2 EUR
              -2 EUR  John Doe
--------------------
                   0
\f[R]
.fi
.PP
One way to show only amounts with a member: value (using a query,
described below):
.IP
.nf
\f[C]
$ hledger balance --pivot member tag:member=.
              -2 EUR  John Doe
--------------------
              -2 EUR
\f[R]
.fi
.PP
Another way (the acct: query matches against the pivoted \[dq]account
name\[dq]):
.IP
.nf
\f[C]
$ hledger balance --pivot member acct:.
              -2 EUR  John Doe
--------------------
              -2 EUR
\f[R]
.fi
.SS Valuation
.PP
hledger can show cost reports, where amounts are converted to their cost
or sale amount at transaction time; or value reports, where amounts are
converted to their market value in another currency/commodity at a
specified date (using market prices inferred from your transactions, or
declared with P directives).
.PP
We call this \[dq]valuation\[dq], and it is controlled by the
\f[C]--value=VALUATIONTYPE[,COMMODITY]\f[R] option.
It can get a little involved, so we cover all the details below.
But most of the time, all you need to do is use these simpler flags
instead:
.IP \[bu] 2
\f[C]-B\f[R] to convert to cost/sale amount, or
.IP \[bu] 2
\f[C]-V\f[R] to convert to market value in your base currency.
Or occasionally,
.IP \[bu] 2
\f[C]-X COMMODITY\f[R] to convert to market value in some other
currency.
.SS -B: Cost
.PP
The \f[C]-B/--cost\f[R] flag converts amounts to their cost or sale
amount at transaction time, if they have a transaction price specified.
(It is equivalent to \f[C]--value=cost\f[R].)
.SS -V: Value
.PP
The \f[C]-V/--market\f[R] flag converts reported amounts to market value
in their \f[I]default valuation commodity\f[R], using the market prices
in effect on a \f[I]default valuation date\f[R].
(More on these below.)
.PP
The default valuation commodity is the one referenced in the latest
applicable market price dated on or before the valuation date.
Typically your P declarations or currency exchange transactions
reference a single base currency, and -V will pick that.
.PP
The default valuation date is today for single period reports
(equivalent to \f[C]--value=now\f[R]), or the last day of each subperiod
for multiperiod reports (equivalent to \f[C]--value=end\f[R]).
.PP
An example:
.IP
.nf
\f[C]
; one euro is worth this many dollars from nov 1
P 2016/11/01 \[Eu] $1.10

; purchase some euros on nov 3
2016/11/3
    assets:euros        \[Eu]100
    assets:checking

; the euro is worth fewer dollars by dec 21
P 2016/12/21 \[Eu] $1.03
\f[R]
.fi
.PP
How many euros do I have ?
.IP
.nf
\f[C]
$ hledger -f t.j bal -N euros
                \[Eu]100  assets:euros
\f[R]
.fi
.PP
What are they worth at end of nov 3 ?
.IP
.nf
\f[C]
$ hledger -f t.j bal -N euros -V -e 2016/11/4
             $110.00  assets:euros
\f[R]
.fi
.PP
What are they worth after 2016/12/21 ?
(no report end date specified, defaults to today)
.IP
.nf
\f[C]
$ hledger -f t.j bal -N euros -V
             $103.00  assets:euros
\f[R]
.fi
.SS -X: Market value in specified commodity
.PP
The \f[C]-X/--exchange\f[R] option is like \f[C]-V\f[R], except it
specifies the target commodity you would like to convert to.
(It is equivalent to \f[C]--value=now,COMM\f[R] or
\f[C]--value=end,COMM\f[R].)
.SS Market prices
.PP
To convert a commodity A to commodity B, hledger looks for a suitable
market price (exchange rate) in the following ways, in this order of
preference:
.IP "1." 3
a \f[I]declared market price\f[R] - the latest P directive specifying
the exchange rate from A to B, dated on or before the valuation date.
.IP "2." 3
a \f[I]transaction-implied market price\f[R] - a market price matching
the transaction price used in the latest transaction where A is
converted to B, dated on or before the valuation date.
(\f[I]since hledger 1.18; experimental\f[R])
.IP "3." 3
a \f[I]reverse declared market price\f[R] - calculated by inverting a
declared market price from B to A.
.IP "4." 3
a \f[I]reverse transaction-implied market price\f[R] - calculated by
inverting a transaction-implied market price from B to A.
.IP "5." 3
an \f[I]indirect market price\f[R] - calculated by combining the
shortest chain of market prices (any of the above types) leading from A
to B.
.SS --value: Flexible valuation
.PP
\f[I](experimental, added 201905)\f[R]
.PP
\f[C]-B\f[R], \f[C]-V\f[R] and \f[C]-X\f[R] are special cases of the
more general \f[C]--value\f[R] option:
.IP
.nf
\f[C]
 --value=TYPE[,COMM]  TYPE is cost, then, end, now or YYYY-MM-DD.
                      COMM is an optional commodity symbol.
                      Shows amounts converted to:
                      - cost commodity using transaction prices (then optionally to COMM using market prices at period end(s))
                      - default valuation commodity (or COMM) using market prices at posting dates
                      - default valuation commodity (or COMM) using market prices at period end(s)
                      - default valuation commodity (or COMM) using current market prices
                      - default valuation commodity (or COMM) using market prices at some date
\f[R]
.fi
.PP
The TYPE part basically selects either \[dq]cost\[dq], or \[dq]market
value\[dq] plus a valuation date:
.TP
\f[B]\f[CB]--value=cost\f[B]\f[R]
Convert amounts to cost, using the prices recorded in transactions.
.TP
\f[B]\f[CB]--value=then\f[B]\f[R]
Convert amounts to their value in a default valuation commodity, using
market prices on each posting\[aq]s date.
This is currently supported only by the print and register commands.
.TP
\f[B]\f[CB]--value=end\f[B]\f[R]
Convert amounts to their value in a default valuation commodity, using
market prices on the last day of the report period (or if unspecified,
the journal\[aq]s end date); or in multiperiod reports, market prices on
the last day of each subperiod.
.TP
\f[B]\f[CB]--value=now\f[B]\f[R]
Convert amounts to their value in default valuation commodity using
current market prices (as of when report is generated).
.TP
\f[B]\f[CB]--value=YYYY-MM-DD\f[B]\f[R]
Convert amounts to their value in default valuation commodity using
market prices on this date.
.PP
The default valuation commodity is the commodity mentioned in the most
recent applicable market price declaration.
When all your price declarations lead to a single home currency, this
will usually do what you want.
.PP
To select a different valuation commodity, add the optional
\f[C],COMM\f[R] part: a comma, then the target commodity\[aq]s symbol.
Eg: \f[B]\f[CB]--value=now,EUR\f[B]\f[R].
hledger will do its best to convert amounts to this commodity, using:
.IP \[bu] 2
declared prices (from source commodity to valuation commodity)
.IP \[bu] 2
reverse prices (declared prices from valuation to source commodity,
inverted)
.IP \[bu] 2
indirect prices (prices calculated from the shortest chain of declared
or reverse prices from source to valuation commodity)
.PP
in that order.
.PP
Here are some examples showing the effect of \f[C]--value\f[R] as seen
with \f[C]print\f[R]:
.IP
.nf
\f[C]
P 2000-01-01 A  1 B
P 2000-02-01 A  2 B
P 2000-03-01 A  3 B
P 2000-04-01 A  4 B

2000-01-01
  (a)      1 A \[at] 5 B

2000-02-01
  (a)      1 A \[at] 6 B

2000-03-01
  (a)      1 A \[at] 7 B
\f[R]
.fi
.PP
Show the cost of each posting:
.IP
.nf
\f[C]
$ hledger -f- print --value=cost
2000-01-01
    (a)             5 B

2000-02-01
    (a)             6 B

2000-03-01
    (a)             7 B
\f[R]
.fi
.PP
Show the value as of the last day of the report period (2000-02-29):
.IP
.nf
\f[C]
$ hledger -f- print --value=end date:2000/01-2000/03
2000-01-01
    (a)             2 B

2000-02-01
    (a)             2 B
\f[R]
.fi
.PP
With no report period specified, that shows the value as of the last day
of the journal (2000-03-01):
.IP
.nf
\f[C]
$ hledger -f- print --value=end
2000-01-01
    (a)             3 B

2000-02-01
    (a)             3 B

2000-03-01
    (a)             3 B
\f[R]
.fi
.PP
Show the current value (the 2000-04-01 price is still in effect today):
.IP
.nf
\f[C]
$ hledger -f- print --value=now
2000-01-01
    (a)             4 B

2000-02-01
    (a)             4 B

2000-03-01
    (a)             4 B
\f[R]
.fi
.PP
Show the value on 2000/01/15:
.IP
.nf
\f[C]
$ hledger -f- print --value=2000-01-15
2000-01-01
    (a)             1 B

2000-02-01
    (a)             1 B

2000-03-01
    (a)             1 B
\f[R]
.fi
.PP
You may need to explicitly set a commodity\[aq]s display style, when
reverse prices are used.
Eg this output might be surprising:
.IP
.nf
\f[C]
P 2000-01-01 A 2B

2000-01-01
  a  1B
  b
\f[R]
.fi
.IP
.nf
\f[C]
$ hledger print -x -X A
2000-01-01
    a               0
    b               0
\f[R]
.fi
.PP
Explanation: because there\[aq]s no amount or commodity directive
specifying a display style for A, 0.5A gets the default style, which
shows no decimal digits.
Because the displayed amount looks like zero, the commodity symbol and
minus sign are not displayed either.
Adding a commodity directive sets a more useful display style for A:
.IP
.nf
\f[C]
P 2000-01-01 A 2B
commodity 0.00A

2000-01-01
  a  1B
  b
\f[R]
.fi
.IP
.nf
\f[C]
$ hledger print -X A
2000-01-01
    a           0.50A
    b          -0.50A
\f[R]
.fi
.SS Effect of --value on reports
.PP
Here is a reference for how \f[C]--value\f[R] currently affects each
part of hledger\[aq]s reports.
It\[aq]s work in progress, but may be useful for troubleshooting or
reporting bugs.
See also the definitions and notes below.
If you find problems, please report them, ideally with a reproducible
example.
Related: #329, #1083.
.PP
.TS
tab(@);
lw(11.7n) lw(11.2n) lw(11.9n) lw(13.1n) lw(12.4n) lw(9.8n).
T{
Report type
T}@T{
\f[C]-B\f[R], \f[C]--value=cost\f[R]
T}@T{
\f[C]-V\f[R], \f[C]-X\f[R]
T}@T{
\f[C]--value=then\f[R]
T}@T{
\f[C]--value=end\f[R]
T}@T{
\f[C]--value=DATE\f[R], \f[C]--value=now\f[R]
T}
_
T{
\f[B]print\f[R]
T}@T{
T}@T{
T}@T{
T}@T{
T}@T{
T}
T{
posting amounts
T}@T{
cost
T}@T{
value at report end or today
T}@T{
value at posting date
T}@T{
value at report or journal end
T}@T{
value at DATE/today
T}
T{
balance assertions / assignments
T}@T{
unchanged
T}@T{
unchanged
T}@T{
unchanged
T}@T{
unchanged
T}@T{
unchanged
T}
T{
T}@T{
T}@T{
T}@T{
T}@T{
T}@T{
T}
T{
\f[B]register\f[R]
T}@T{
T}@T{
T}@T{
T}@T{
T}@T{
T}
T{
starting balance (with -H)
T}@T{
cost
T}@T{
value at day before report or journal start
T}@T{
not supported
T}@T{
value at day before report or journal start
T}@T{
value at DATE/today
T}
T{
posting amounts (no report interval)
T}@T{
cost
T}@T{
value at report end or today
T}@T{
value at posting date
T}@T{
value at report or journal end
T}@T{
value at DATE/today
T}
T{
summary posting amounts (with report interval)
T}@T{
summarised cost
T}@T{
value at period ends
T}@T{
sum of postings in interval, valued at interval start
T}@T{
value at period ends
T}@T{
value at DATE/today
T}
T{
running total/average
T}@T{
sum/average of displayed values
T}@T{
sum/average of displayed values
T}@T{
sum/average of displayed values
T}@T{
sum/average of displayed values
T}@T{
sum/average of displayed values
T}
T{
T}@T{
T}@T{
T}@T{
T}@T{
T}@T{
T}
T{
\f[B]balance (bs, bse, cf, is..)\f[R]
T}@T{
T}@T{
T}@T{
T}@T{
T}@T{
T}
T{
balances (no report interval)
T}@T{
sums of costs
T}@T{
value at report end or today of sums of postings
T}@T{
not supported
T}@T{
value at report or journal end of sums of postings
T}@T{
value at DATE/today of sums of postings
T}
T{
balances (with report interval)
T}@T{
sums of costs
T}@T{
value at period ends of sums of postings
T}@T{
not supported
T}@T{
value at period ends of sums of postings
T}@T{
value at DATE/today of sums of postings
T}
T{
starting balances (with report interval and -H)
T}@T{
sums of costs of postings before report start
T}@T{
sums of postings before report start
T}@T{
not supported
T}@T{
sums of postings before report start
T}@T{
sums of postings before report start
T}
T{
budget amounts with --budget
T}@T{
like balances
T}@T{
like balances
T}@T{
not supported
T}@T{
like balances
T}@T{
like balances
T}
T{
grand total (no report interval)
T}@T{
sum of displayed values
T}@T{
sum of displayed values
T}@T{
not supported
T}@T{
sum of displayed values
T}@T{
sum of displayed values
T}
T{
row totals/averages (with report interval)
T}@T{
sums/averages of displayed values
T}@T{
sums/averages of displayed values
T}@T{
not supported
T}@T{
sums/averages of displayed values
T}@T{
sums/averages of displayed values
T}
T{
column totals
T}@T{
sums of displayed values
T}@T{
sums of displayed values
T}@T{
not supported
T}@T{
sums of displayed values
T}@T{
sums of displayed values
T}
T{
grand total/average
T}@T{
sum/average of column totals
T}@T{
sum/average of column totals
T}@T{
not supported
T}@T{
sum/average of column totals
T}@T{
sum/average of column totals
T}
T{
T}@T{
T}@T{
T}@T{
T}@T{
T}@T{
T}
.TE
.PP
\f[B]Additional notes\f[R]
.TP
\f[I]cost\f[R]
calculated using price(s) recorded in the transaction(s).
.TP
\f[I]value\f[R]
market value using available market price declarations, or the unchanged
amount if no conversion rate can be found.
.TP
\f[I]report start\f[R]
the first day of the report period specified with -b or -p or date:,
otherwise today.
.TP
\f[I]report or journal start\f[R]
the first day of the report period specified with -b or -p or date:,
otherwise the earliest transaction date in the journal, otherwise today.
.TP
\f[I]report end\f[R]
the last day of the report period specified with -e or -p or date:,
otherwise today.
.TP
\f[I]report or journal end\f[R]
the last day of the report period specified with -e or -p or date:,
otherwise the latest transaction date in the journal, otherwise today.
.TP
\f[I]report interval\f[R]
a flag (-D/-W/-M/-Q/-Y) or period expression that activates the
report\[aq]s multi-period mode (whether showing one or many subperiods).
.SH COMMANDS
.PP
hledger provides a number of subcommands; \f[C]hledger\f[R] with no
arguments shows a list.
.PP
If you install additional \f[C]hledger-*\f[R] packages, or if you put
programs or scripts named \f[C]hledger-NAME\f[R] in your PATH, these
will also be listed as subcommands.
.PP
Run a subcommand by writing its name as first argument (eg
\f[C]hledger incomestatement\f[R]).
You can also write one of the standard short aliases displayed in
parentheses in the command list (\f[C]hledger b\f[R]), or any any
unambiguous prefix of a command name (\f[C]hledger inc\f[R]).
.PP
Here are all the builtin commands in alphabetical order.
See also \f[C]hledger\f[R] for a more organised command list, and
\f[C]hledger CMD -h\f[R] for detailed command help.
.SS accounts
.PP
accounts, a
.PD 0
.P
.PD
Show account names.
.PP
This command lists account names, either declared with account
directives (--declared), posted to (--used), or both (the default).
With query arguments, only matched account names and account names
referenced by matched postings are shown.
It shows a flat list by default.
With \f[C]--tree\f[R], it uses indentation to show the account
hierarchy.
In flat mode you can add \f[C]--drop N\f[R] to omit the first few
account name components.
Account names can be depth-clipped with \f[C]depth:N\f[R] or
\f[C]--depth N\f[R] or \f[C]-N\f[R].
.PP
Examples:
.IP
.nf
\f[C]
$ hledger accounts
assets:bank:checking
assets:bank:saving
assets:cash
expenses:food
expenses:supplies
income:gifts
income:salary
liabilities:debts
\f[R]
.fi
.SS activity
.PP
activity
.PD 0
.P
.PD
Show an ascii barchart of posting counts per interval.
.PP
The activity command displays an ascii histogram showing transaction
counts by day, week, month or other reporting interval (by day is the
default).
With query arguments, it counts only matched transactions.
.PP
Examples:
.IP
.nf
\f[C]
$ hledger activity --quarterly
2008-01-01 **
2008-04-01 *******
2008-07-01 
2008-10-01 **
\f[R]
.fi
.SS add
.PP
add
.PD 0
.P
.PD
Prompt for transactions and add them to the journal.
.PP
Many hledger users edit their journals directly with a text editor, or
generate them from CSV.
For more interactive data entry, there is the \f[C]add\f[R] command,
which prompts interactively on the console for new transactions, and
appends them to the journal file (if there are multiple
\f[C]-f FILE\f[R] options, the first file is used.) Existing
transactions are not changed.
This is the only hledger command that writes to the journal file.
.PP
To use it, just run \f[C]hledger add\f[R] and follow the prompts.
You can add as many transactions as you like; when you are finished,
enter \f[C].\f[R] or press control-d or control-c to exit.
.PP
Features:
.IP \[bu] 2
add tries to provide useful defaults, using the most similar (by
description) recent transaction (filtered by the query, if any) as a
template.
.IP \[bu] 2
You can also set the initial defaults with command line arguments.
.IP \[bu] 2
Readline-style edit keys can be used during data entry.
.IP \[bu] 2
The tab key will auto-complete whenever possible - accounts,
descriptions, dates (\f[C]yesterday\f[R], \f[C]today\f[R],
\f[C]tomorrow\f[R]).
If the input area is empty, it will insert the default value.
.IP \[bu] 2
If the journal defines a default commodity, it will be added to any bare
numbers entered.
.IP \[bu] 2
A parenthesised transaction code may be entered following a date.
.IP \[bu] 2
Comments and tags may be entered following a description or amount.
.IP \[bu] 2
If you make a mistake, enter \f[C]<\f[R] at any prompt to go one step
backward.
.IP \[bu] 2
Input prompts are displayed in a different colour when the terminal
supports it.
.PP
Example (see the tutorial for a detailed explanation):
.IP
.nf
\f[C]
$ hledger add
Adding transactions to journal file /src/hledger/examples/sample.journal
Any command line arguments will be used as defaults.
Use tab key to complete, readline keys to edit, enter to accept defaults.
An optional (CODE) may follow transaction dates.
An optional ; COMMENT may follow descriptions or amounts.
If you make a mistake, enter < at any prompt to go one step backward.
To end a transaction, enter . when prompted.
To quit, enter . at a date prompt or press control-d or control-c.
Date [2015/05/22]: 
Description: supermarket
Account 1: expenses:food
Amount  1: $10
Account 2: assets:checking
Amount  2 [$-10.0]: 
Account 3 (or . or enter to finish this transaction): .
2015/05/22 supermarket
    expenses:food             $10
    assets:checking        $-10.0

Save this transaction to the journal ? [y]: 
Saved.
Starting the next transaction (. or ctrl-D/ctrl-C to quit)
Date [2015/05/22]: <CTRL-D> $
\f[R]
.fi
.PP
On Microsoft Windows, the add command makes sure that no part of the
file path ends with a period, as it can cause data loss on that platform
(cf #1056).
.SS balance
.PP
balance, bal, b
.PD 0
.P
.PD
Show accounts and their balances.
.PP
The balance command is hledger\[aq]s most versatile command.
Note, despite the name, it is not always used for showing real-world
account balances; the more accounting-aware balancesheet and
incomestatement may be more convenient for that.
.PP
By default, it displays all accounts, and each account\[aq]s change in
balance during the entire period of the journal.
Balance changes are calculated by adding up the postings in each
account.
You can limit the postings matched, by a query, to see fewer accounts,
changes over a different time period, changes from only cleared
transactions, etc.
.PP
If you include an account\[aq]s complete history of postings in the
report, the balance change is equivalent to the account\[aq]s current
ending balance.
For a real-world account, typically you won\[aq]t have all transactions
in the journal; instead you\[aq]ll have all transactions after a certain
date, and an \[dq]opening balances\[dq] transaction setting the correct
starting balance on that date.
Then the balance command will show real-world account balances.
In some cases the -H/--historical flag is used to ensure this (more
below).
.PP
The balance command can produce several styles of report:
.SS Classic balance report
.PP
This is the original balance report, as found in Ledger.
It usually looks like this:
.IP
.nf
\f[C]
$ hledger balance
                 $-1  assets
                  $1    bank:saving
                 $-2    cash
                  $2  expenses
                  $1    food
                  $1    supplies
                 $-2  income
                 $-1    gifts
                 $-1    salary
                  $1  liabilities:debts
--------------------
                   0
\f[R]
.fi
.PP
By default, accounts are displayed hierarchically, with subaccounts
indented below their parent.
At each level of the tree, accounts are sorted by account code if any,
then by account name.
Or with \f[C]-S/--sort-amount\f[R], by their balance amount.
.PP
\[dq]Boring\[dq] accounts, which contain a single interesting subaccount
and no balance of their own, are elided into the following line for more
compact output.
(Eg above, the \[dq]liabilities\[dq] account.) Use \f[C]--no-elide\f[R]
to prevent this.
.PP
Account balances are \[dq]inclusive\[dq] - they include the balances of
any subaccounts.
.PP
Accounts which have zero balance (and no non-zero subaccounts) are
omitted.
Use \f[C]-E/--empty\f[R] to show them.
.PP
A final total is displayed by default; use \f[C]-N/--no-total\f[R] to
suppress it, eg:
.IP
.nf
\f[C]
$ hledger balance -p 2008/6 expenses --no-total
                  $2  expenses
                  $1    food
                  $1    supplies
\f[R]
.fi
.SS Customising the classic balance report
.PP
You can customise the layout of classic balance reports with
\f[C]--format FMT\f[R]:
.IP
.nf
\f[C]
$ hledger balance --format \[dq]%20(account) %12(total)\[dq]
              assets          $-1
         bank:saving           $1
                cash          $-2
            expenses           $2
                food           $1
            supplies           $1
              income          $-2
               gifts          $-1
              salary          $-1
   liabilities:debts           $1
---------------------------------
                                0
\f[R]
.fi
.PP
The FMT format string (plus a newline) specifies the formatting applied
to each account/balance pair.
It may contain any suitable text, with data fields interpolated like so:
.PP
\f[C]%[MIN][.MAX](FIELDNAME)\f[R]
.IP \[bu] 2
MIN pads with spaces to at least this width (optional)
.IP \[bu] 2
MAX truncates at this width (optional)
.IP \[bu] 2
FIELDNAME must be enclosed in parentheses, and can be one of:
.RS 2
.IP \[bu] 2
\f[C]depth_spacer\f[R] - a number of spaces equal to the account\[aq]s
depth, or if MIN is specified, MIN * depth spaces.
.IP \[bu] 2
\f[C]account\f[R] - the account\[aq]s name
.IP \[bu] 2
\f[C]total\f[R] - the account\[aq]s balance/posted total, right
justified
.RE
.PP
Also, FMT can begin with an optional prefix to control how
multi-commodity amounts are rendered:
.IP \[bu] 2
\f[C]%_\f[R] - render on multiple lines, bottom-aligned (the default)
.IP \[bu] 2
\f[C]%\[ha]\f[R] - render on multiple lines, top-aligned
.IP \[bu] 2
\f[C]%,\f[R] - render on one line, comma-separated
.PP
There are some quirks.
Eg in one-line mode, \f[C]%(depth_spacer)\f[R] has no effect, instead
\f[C]%(account)\f[R] has indentation built in.
Experimentation may be needed to get pleasing results.
.PP
Some example formats:
.IP \[bu] 2
\f[C]%(total)\f[R] - the account\[aq]s total
.IP \[bu] 2
\f[C]%-20.20(account)\f[R] - the account\[aq]s name, left justified,
padded to 20 characters and clipped at 20 characters
.IP \[bu] 2
\f[C]%,%-50(account)  %25(total)\f[R] - account name padded to 50
characters, total padded to 20 characters, with multiple commodities
rendered on one line
.IP \[bu] 2
\f[C]%20(total)  %2(depth_spacer)%-(account)\f[R] - the default format
for the single-column balance report
.SS Colour support
.PP
The balance command shows negative amounts in red, if:
.IP \[bu] 2
the \f[C]TERM\f[R] environment variable is not set to \f[C]dumb\f[R]
.IP \[bu] 2
the output is not being redirected or piped anywhere
.SS Flat mode
.PP
To see a flat list instead of the default hierarchical display, use
\f[C]--flat\f[R].
In this mode, accounts (unless depth-clipped) show their full names and
\[dq]exclusive\[dq] balance, excluding any subaccount balances.
In this mode, you can also use \f[C]--drop N\f[R] to omit the first few
account name components.
.IP
.nf
\f[C]
$ hledger balance -p 2008/6 expenses -N --flat --drop 1
                  $1  food
                  $1  supplies
\f[R]
.fi
.SS Depth limited balance reports
.PP
With \f[C]--depth N\f[R] or \f[C]depth:N\f[R] or just \f[C]-N\f[R],
balance reports show accounts only to the specified numeric depth.
This is very useful to summarise a complex set of accounts and get an
overview.
.IP
.nf
\f[C]
$ hledger balance -N -1
                 $-1  assets
                  $2  expenses
                 $-2  income
                  $1  liabilities
\f[R]
.fi
.PP
Flat-mode balance reports, which normally show exclusive balances, show
inclusive balances at the depth limit.
.SS Percentages
.PP
With \f[C]-%\f[R] or \f[C]--percent\f[R], balance reports show each
account\[aq]s value expressed as a percentage of the column\[aq]s total.
This is useful to get an overview of the relative sizes of account
balances.
For example to obtain an overview of expenses:
.IP
.nf
\f[C]
$ hledger balance expenses -%
             100.0 %  expenses
              50.0 %    food
              50.0 %    supplies
--------------------
             100.0 %
\f[R]
.fi
.PP
Note that \f[C]--tree\f[R] does not have an effect on \f[C]-%\f[R].
The percentages are always relative to the total sum of each column,
they are never relative to the parent account.
.PP
Since the percentages are relative to the columns sum, it is usually not
useful to calculate percentages if the signs of the amounts are mixed.
Although the results are technically correct, they are most likely
useless.
Especially in a balance report that sums up to zero (eg
\f[C]hledger balance -B\f[R]) all percentage values will be zero.
.PP
This flag does not work if the report contains any mixed commodity
accounts.
If there are mixed commodity accounts in the report be sure to use
\f[C]-V\f[R] or \f[C]-B\f[R] to coerce the report into using a single
commodity.
.SS Multicolumn balance report
.PP
Multicolumn or tabular balance reports are a very useful hledger
feature, and usually the preferred style.
They share many of the above features, but they show the report as a
table, with columns representing time periods.
This mode is activated by providing a reporting interval.
.PP
There are three types of multicolumn balance report, showing different
information:
.IP "1." 3
By default: each column shows the sum of postings in that period, ie the
account\[aq]s change of balance in that period.
This is useful eg for a monthly income statement:
.RS 4
.IP
.nf
\f[C]
$ hledger balance --quarterly income expenses -E
Balance changes in 2008:

                   ||  2008q1  2008q2  2008q3  2008q4 
===================++=================================
 expenses:food     ||       0      $1       0       0 
 expenses:supplies ||       0      $1       0       0 
 income:gifts      ||       0     $-1       0       0 
 income:salary     ||     $-1       0       0       0 
-------------------++---------------------------------
                   ||     $-1      $1       0       0 
\f[R]
.fi
.RE
.IP "2." 3
With \f[C]--cumulative\f[R]: each column shows the ending balance for
that period, accumulating the changes across periods, starting from 0 at
the report start date:
.RS 4
.IP
.nf
\f[C]
$ hledger balance --quarterly income expenses -E --cumulative
Ending balances (cumulative) in 2008:

                   ||  2008/03/31  2008/06/30  2008/09/30  2008/12/31 
===================++=================================================
 expenses:food     ||           0          $1          $1          $1 
 expenses:supplies ||           0          $1          $1          $1 
 income:gifts      ||           0         $-1         $-1         $-1 
 income:salary     ||         $-1         $-1         $-1         $-1 
-------------------++-------------------------------------------------
                   ||         $-1           0           0           0 
\f[R]
.fi
.RE
.IP "3." 3
With \f[C]--historical/-H\f[R]: each column shows the actual historical
ending balance for that period, accumulating the changes across periods,
starting from the actual balance at the report start date.
This is useful eg for a multi-period balance sheet, and when you are
showing only the data after a certain start date:
.RS 4
.IP
.nf
\f[C]
$ hledger balance \[ha]assets \[ha]liabilities --quarterly --historical --begin 2008/4/1
Ending balances (historical) in 2008/04/01-2008/12/31:

                      ||  2008/06/30  2008/09/30  2008/12/31 
======================++=====================================
 assets:bank:checking ||          $1          $1           0 
 assets:bank:saving   ||          $1          $1          $1 
 assets:cash          ||         $-2         $-2         $-2 
 liabilities:debts    ||           0           0          $1 
----------------------++-------------------------------------
                      ||           0           0           0 
\f[R]
.fi
.RE
.PP
Note that \f[C]--cumulative\f[R] or \f[C]--historical/-H\f[R] disable
\f[C]--row-total/-T\f[R], since summing end balances generally does not
make sense.
.PP
Multicolumn balance reports display accounts in flat mode by default; to
see the hierarchy, use \f[C]--tree\f[R].
.PP
With a reporting interval (like \f[C]--quarterly\f[R] above), the report
start/end dates will be adjusted if necessary so that they encompass the
displayed report periods.
This is so that the first and last periods will be \[dq]full\[dq] and
comparable to the others.
.PP
The \f[C]-E/--empty\f[R] flag does two things in multicolumn balance
reports: first, the report will show all columns within the specified
report period (without -E, leading and trailing columns with all zeroes
are not shown).
Second, all accounts which existed at the report start date will be
considered, not just the ones with activity during the report period
(use -E to include low-activity accounts which would otherwise would be
omitted).
.PP
The \f[C]-T/--row-total\f[R] flag adds an additional column showing the
total for each row.
.PP
The \f[C]-A/--average\f[R] flag adds a column showing the average value
in each row.
.PP
Here\[aq]s an example of all three:
.IP
.nf
\f[C]
$ hledger balance -Q income expenses --tree -ETA
Balance changes in 2008:

            ||  2008q1  2008q2  2008q3  2008q4    Total  Average 
============++===================================================
 expenses   ||       0      $2       0       0       $2       $1 
   food     ||       0      $1       0       0       $1        0 
   supplies ||       0      $1       0       0       $1        0 
 income     ||     $-1     $-1       0       0      $-2      $-1 
   gifts    ||       0     $-1       0       0      $-1        0 
   salary   ||     $-1       0       0       0      $-1        0 
------------++---------------------------------------------------
            ||     $-1      $1       0       0        0        0 

(Average is rounded to the dollar here since all journal amounts are)
\f[R]
.fi
.PP
A limitation of multicolumn balance reports: eliding of boring parent
accounts in tree mode, as in the classic balance report, is not yet
supported.
.PP
The \f[C]--transpose\f[R] flag can be used to exchange the rows and
columns of a multicolumn report.
.SS Budget report
.PP
With \f[C]--budget\f[R], extra columns are displayed showing budget
goals for each account and period, if any.
Budget goals are defined by periodic transactions.
This is very useful for comparing planned and actual income, expenses,
time usage, etc.
--budget is most often combined with a report interval.
.PP
For example, you can take average monthly expenses in the common expense
categories to construct a minimal monthly budget:
.IP
.nf
\f[C]
;; Budget
\[ti] monthly
  income  $2000
  expenses:food    $400
  expenses:bus     $50
  expenses:movies  $30
  assets:bank:checking

;; Two months worth of expenses
2017-11-01
  income  $1950
  expenses:food    $396
  expenses:bus     $49
  expenses:movies  $30
  expenses:supplies  $20
  assets:bank:checking

2017-12-01
  income  $2100
  expenses:food    $412
  expenses:bus     $53
  expenses:gifts   $100
  assets:bank:checking
\f[R]
.fi
.PP
You can now see a monthly budget report:
.IP
.nf
\f[C]
$ hledger balance -M --budget
Budget performance in 2017/11/01-2017/12/31:

                      ||                      Nov                       Dec 
======================++====================================================
 assets               || $-2445 [  99% of $-2480]  $-2665 [ 107% of $-2480] 
 assets:bank          || $-2445 [  99% of $-2480]  $-2665 [ 107% of $-2480] 
 assets:bank:checking || $-2445 [  99% of $-2480]  $-2665 [ 107% of $-2480] 
 expenses             ||   $495 [ 103% of   $480]    $565 [ 118% of   $480] 
 expenses:bus         ||    $49 [  98% of    $50]     $53 [ 106% of    $50] 
 expenses:food        ||   $396 [  99% of   $400]    $412 [ 103% of   $400] 
 expenses:movies      ||    $30 [ 100% of    $30]       0 [   0% of    $30] 
 income               ||  $1950 [  98% of  $2000]   $2100 [ 105% of  $2000] 
----------------------++----------------------------------------------------
                      ||      0 [              0]       0 [              0] 
\f[R]
.fi
.PP
This is different from a normal balance report in several ways:
.IP \[bu] 2
Only accounts with budget goals during the report period are shown, by
default.
.IP \[bu] 2
In each column, in square brackets after the actual amount, budget goal
amounts are shown, and the actual/goal percentage.
(Note: budget goals should be in the same commodity as the actual
amount.)
.IP \[bu] 2
All parent accounts are always shown, even in flat mode.
Eg assets, assets:bank, and expenses above.
.IP \[bu] 2
Amounts always include all subaccounts, budgeted or unbudgeted, even in
flat mode.
.PP
This means that the numbers displayed will not always add up! Eg above,
the \f[C]expenses\f[R] actual amount includes the gifts and supplies
transactions, but the \f[C]expenses:gifts\f[R] and
\f[C]expenses:supplies\f[R] accounts are not shown, as they have no
budget amounts declared.
.PP
This can be confusing.
When you need to make things clearer, use the \f[C]-E/--empty\f[R] flag,
which will reveal all accounts including unbudgeted ones, giving the
full picture.
Eg:
.IP
.nf
\f[C]
$ hledger balance -M --budget --empty
Budget performance in 2017/11/01-2017/12/31:

                      ||                      Nov                       Dec 
======================++====================================================
 assets               || $-2445 [  99% of $-2480]  $-2665 [ 107% of $-2480] 
 assets:bank          || $-2445 [  99% of $-2480]  $-2665 [ 107% of $-2480] 
 assets:bank:checking || $-2445 [  99% of $-2480]  $-2665 [ 107% of $-2480] 
 expenses             ||   $495 [ 103% of   $480]    $565 [ 118% of   $480] 
 expenses:bus         ||    $49 [  98% of    $50]     $53 [ 106% of    $50] 
 expenses:food        ||   $396 [  99% of   $400]    $412 [ 103% of   $400] 
 expenses:gifts       ||      0                      $100                   
 expenses:movies      ||    $30 [ 100% of    $30]       0 [   0% of    $30] 
 expenses:supplies    ||    $20                         0                   
 income               ||  $1950 [  98% of  $2000]   $2100 [ 105% of  $2000] 
----------------------++----------------------------------------------------
                      ||      0 [              0]       0 [              0] 
\f[R]
.fi
.PP
You can roll over unspent budgets to next period with
\f[C]--cumulative\f[R]:
.IP
.nf
\f[C]
$ hledger balance -M --budget --cumulative
Budget performance in 2017/11/01-2017/12/31:

                      ||                      Nov                       Dec 
======================++====================================================
 assets               || $-2445 [  99% of $-2480]  $-5110 [ 103% of $-4960] 
 assets:bank          || $-2445 [  99% of $-2480]  $-5110 [ 103% of $-4960] 
 assets:bank:checking || $-2445 [  99% of $-2480]  $-5110 [ 103% of $-4960] 
 expenses             ||   $495 [ 103% of   $480]   $1060 [ 110% of   $960] 
 expenses:bus         ||    $49 [  98% of    $50]    $102 [ 102% of   $100] 
 expenses:food        ||   $396 [  99% of   $400]    $808 [ 101% of   $800] 
 expenses:movies      ||    $30 [ 100% of    $30]     $30 [  50% of    $60] 
 income               ||  $1950 [  98% of  $2000]   $4050 [ 101% of  $4000] 
----------------------++----------------------------------------------------
                      ||      0 [              0]       0 [              0] 
\f[R]
.fi
.PP
For more examples, see Budgeting and Forecasting.
.SS Nested budgets
.PP
You can add budgets to any account in your account hierarchy.
If you have budgets on both parent account and some of its children,
then budget(s) of the child account(s) would be added to the budget of
their parent, much like account balances behave.
.PP
In the most simple case this means that once you add a budget to any
account, all its parents would have budget as well.
.PP
To illustrate this, consider the following budget:
.IP
.nf
\f[C]
\[ti] monthly from 2019/01
    expenses:personal             $1,000.00
    expenses:personal:electronics    $100.00
    liabilities
\f[R]
.fi
.PP
With this, monthly budget for electronics is defined to be $100 and
budget for personal expenses is an additional $1000, which implicitly
means that budget for both \f[C]expenses:personal\f[R] and
\f[C]expenses\f[R] is $1100.
.PP
Transactions in \f[C]expenses:personal:electronics\f[R] will be counted
both towards its $100 budget and $1100 of \f[C]expenses:personal\f[R] ,
and transactions in any other subaccount of \f[C]expenses:personal\f[R]
would be counted towards only towards the budget of
\f[C]expenses:personal\f[R].
.PP
For example, let\[aq]s consider these transactions:
.IP
.nf
\f[C]
\[ti] monthly from 2019/01
    expenses:personal             $1,000.00
    expenses:personal:electronics    $100.00
    liabilities

2019/01/01 Google home hub
    expenses:personal:electronics          $90.00
    liabilities                           $-90.00

2019/01/02 Phone screen protector
    expenses:personal:electronics:upgrades          $10.00
    liabilities

2019/01/02 Weekly train ticket
    expenses:personal:train tickets       $153.00
    liabilities

2019/01/03 Flowers
    expenses:personal          $30.00
    liabilities
\f[R]
.fi
.PP
As you can see, we have transactions in
\f[C]expenses:personal:electronics:upgrades\f[R] and
\f[C]expenses:personal:train tickets\f[R], and since both of these
accounts are without explicitly defined budget, these transactions would
be counted towards budgets of \f[C]expenses:personal:electronics\f[R]
and \f[C]expenses:personal\f[R] accordingly:
.IP
.nf
\f[C]
$ hledger balance --budget -M
Budget performance in 2019/01:

                               ||                           Jan 
===============================++===============================
 expenses                      ||  $283.00 [  26% of  $1100.00] 
 expenses:personal             ||  $283.00 [  26% of  $1100.00] 
 expenses:personal:electronics ||  $100.00 [ 100% of   $100.00] 
 liabilities                   || $-283.00 [  26% of $-1100.00] 
-------------------------------++-------------------------------
                               ||        0 [                 0] 
\f[R]
.fi
.PP
And with \f[C]--empty\f[R], we can get a better picture of budget
allocation and consumption:
.IP
.nf
\f[C]
$ hledger balance --budget -M --empty
Budget performance in 2019/01:

                                        ||                           Jan 
========================================++===============================
 expenses                               ||  $283.00 [  26% of  $1100.00] 
 expenses:personal                      ||  $283.00 [  26% of  $1100.00] 
 expenses:personal:electronics          ||  $100.00 [ 100% of   $100.00] 
 expenses:personal:electronics:upgrades ||   $10.00                      
 expenses:personal:train tickets        ||  $153.00                      
 liabilities                            || $-283.00 [  26% of $-1100.00] 
----------------------------------------++-------------------------------
                                        ||        0 [                 0] 
\f[R]
.fi
.SS Output format
.PP
This command also supports the output destination and output format
options The output formats supported are \f[C]txt\f[R], \f[C]csv\f[R],
(multicolumn non-budget reports only) \f[C]html\f[R], and (experimental)
\f[C]json\f[R].
.SS balancesheet
.PP
balancesheet, bs
.PD 0
.P
.PD
This command displays a simple balance sheet, showing historical ending
balances of asset and liability accounts (ignoring any report begin
date).
It assumes that these accounts are under a top-level \f[C]asset\f[R] or
\f[C]liability\f[R] account (case insensitive, plural forms also
allowed).
.PP
Note this report shows all account balances with normal positive sign
(like conventional financial statements, unlike balance/print/register)
(experimental).
.PP
Example:
.IP
.nf
\f[C]
$ hledger balancesheet
Balance Sheet

Assets:
                 $-1  assets
                  $1    bank:saving
                 $-2    cash
--------------------
                 $-1

Liabilities:
                  $1  liabilities:debts
--------------------
                  $1

Total:
--------------------
                   0
\f[R]
.fi
.PP
With a reporting interval, multiple columns will be shown, one for each
report period.
As with multicolumn balance reports, you can alter the report mode with
\f[C]--change\f[R]/\f[C]--cumulative\f[R]/\f[C]--historical\f[R].
Normally balancesheet shows historical ending balances, which is what
you need for a balance sheet; note this means it ignores report begin
dates (and \f[C]-T/--row-total\f[R], since summing end balances
generally does not make sense).
Instead of absolute values percentages can be displayed with
\f[C]-%\f[R].
.PP
This command also supports the output destination and output format
options The output formats supported are \f[C]txt\f[R], \f[C]csv\f[R],
\f[C]html\f[R], and (experimental) \f[C]json\f[R].
.SS balancesheetequity
.PP
balancesheetequity, bse
.PD 0
.P
.PD
Just like balancesheet, but also reports Equity (which it assumes is
under a top-level \f[C]equity\f[R] account).
.PP
Example:
.IP
.nf
\f[C]
$ hledger balancesheetequity
Balance Sheet With Equity

Assets:
                 $-2  assets
                  $1    bank:saving
                 $-3    cash
--------------------
                 $-2

Liabilities:
                  $1  liabilities:debts
--------------------
                  $1

Equity:
          $1  equity:owner
--------------------
          $1

Total:
--------------------
                   0
\f[R]
.fi
.PP
This command also supports the output destination and output format
options The output formats supported are \f[C]txt\f[R], \f[C]csv\f[R],
\f[C]html\f[R], and (experimental) \f[C]json\f[R].
.SS cashflow
.PP
cashflow, cf
.PD 0
.P
.PD
This command displays a simple cashflow statement, showing changes in
\[dq]cash\[dq] accounts.
It assumes that these accounts are under a top-level \f[C]asset\f[R]
account (case insensitive, plural forms also allowed) and do not contain
\f[C]receivable\f[R] or \f[C]A/R\f[R] in their name.
Note this report shows all account balances with normal positive sign
(like conventional financial statements, unlike balance/print/register)
(experimental).
.PP
Example:
.IP
.nf
\f[C]
$ hledger cashflow
Cashflow Statement

Cash flows:
                 $-1  assets
                  $1    bank:saving
                 $-2    cash
--------------------
                 $-1

Total:
--------------------
                 $-1
\f[R]
.fi
.PP
With a reporting interval, multiple columns will be shown, one for each
report period.
Normally cashflow shows changes in assets per period, though as with
multicolumn balance reports you can alter the report mode with
\f[C]--change\f[R]/\f[C]--cumulative\f[R]/\f[C]--historical\f[R].
Instead of absolute values percentages can be displayed with
\f[C]-%\f[R].
.PP
This command also supports the output destination and output format
options The output formats supported are \f[C]txt\f[R], \f[C]csv\f[R],
\f[C]html\f[R], and (experimental) \f[C]json\f[R].
.SS check-dates
.PP
check-dates
.PD 0
.P
.PD
Check that transactions are sorted by increasing date.
With --date2, checks secondary dates instead.
With --strict, dates must also be unique.
With a query, only matched transactions\[aq] dates are checked.
Reads the default journal file, or another specified with -f.
.SS check-dupes
.PP
check-dupes
.PD 0
.P
.PD
Reports account names having the same leaf but different prefixes.
In other words, two or more leaves that are categorized differently.
Reads the default journal file, or another specified as an argument.
.PP
An example: http://stefanorodighiero.net/software/hledger-dupes.html
.SS close
.PP
close, equity
.PD 0
.P
.PD
Prints a \[dq]closing balances\[dq] transaction and an \[dq]opening
balances\[dq] transaction that bring account balances to and from zero,
respectively.
These can be added to your journal file(s), eg to bring asset/liability
balances forward into a new journal file, or to close out
revenues/expenses to retained earnings at the end of a period.
.PP
You can print just one of these transactions by using the
\f[C]--close\f[R] or \f[C]--open\f[R] flag.
You can customise their descriptions with the \f[C]--close-desc\f[R] and
\f[C]--open-desc\f[R] options.
.PP
One amountless posting to \[dq]equity:opening/closing balances\[dq] is
added to balance the transactions, by default.
You can customise this account name with \f[C]--close-acct\f[R] and
\f[C]--open-acct\f[R]; if you specify only one of these, it will be used
for both.
.PP
With \f[C]--x/--explicit\f[R], the equity posting\[aq]s amount will be
shown.
And if it involves multiple commodities, a posting for each commodity
will be shown, as with the print command.
.PP
With \f[C]--interleaved\f[R], the equity postings are shown next to the
postings they balance, which makes troubleshooting easier.
.PP
By default, transaction prices in the journal are ignored when
generating the closing/opening transactions.
With \f[C]--show-costs\f[R], this cost information is preserved
(\f[C]balance -B\f[R] reports will be unchanged after the transition).
Separate postings are generated for each cost in each commodity.
Note this can generate very large journal entries, if you have many
foreign currency or investment transactions.
.SS close usage
.PP
If you split your journal files by time (eg yearly), you will typically
run this command at the end of the year, and save the closing
transaction as last entry of the old file, and the opening transaction
as the first entry of the new file.
This makes the files self contained, so that correct balances are
reported no matter which of them are loaded.
Ie, if you load just one file, the balances are initialised correctly;
or if you load several files, the redundant closing/opening transactions
cancel each other out.
(They will show up in print or register reports; you can exclude them
with a query like
\f[C]not:desc:\[aq](opening|closing) balances\[aq]\f[R].)
.PP
If you\[aq]re running a business, you might also use this command to
\[dq]close the books\[dq] at the end of an accounting period,
transferring income statement account balances to retained earnings.
(You may want to change the equity account name to something like
\[dq]equity:retained earnings\[dq].)
.PP
By default, the closing transaction is dated yesterday, the balances are
calculated as of end of yesterday, and the opening transaction is dated
today.
To close on some other date, use:
\f[C]hledger close -e OPENINGDATE\f[R].
Eg, to close/open on the 2018/2019 boundary, use \f[C]-e 2019\f[R].
You can also use -p or \f[C]date:PERIOD\f[R] (any starting date is
ignored).
.PP
Both transactions will include balance assertions for the
closed/reopened accounts.
You probably shouldn\[aq]t use status or realness filters (like -C or -R
or \f[C]status:\f[R]) with this command, or the generated balance
assertions will depend on these flags.
Likewise, if you run this command with --auto, the balance assertions
will probably always require --auto.
.PP
Examples:
.PP
Carrying asset/liability balances into a new file for 2019:
.IP
.nf
\f[C]
$ hledger close -f 2018.journal -e 2019 assets liabilities --open
    # (copy/paste the output to the start of your 2019 journal file)
$ hledger close -f 2018.journal -e 2019 assets liabilities --close
    # (copy/paste the output to the end of your 2018 journal file)
\f[R]
.fi
.PP
Now:
.IP
.nf
\f[C]
$ hledger bs -f 2019.journal                   # one file - balances are correct
$ hledger bs -f 2018.journal -f 2019.journal   # two files - balances still correct
$ hledger bs -f 2018.journal not:desc:closing  # to see year-end balances, must exclude closing txn
\f[R]
.fi
.PP
Transactions spanning the closing date can complicate matters, breaking
balance assertions:
.IP
.nf
\f[C]
2018/12/30 a purchase made in 2018, clearing the following year
    expenses:food          5
    assets:bank:checking  -5  ; [2019/1/2]
\f[R]
.fi
.PP
Here\[aq]s one way to resolve that:
.IP
.nf
\f[C]
; in 2018.journal:
2018/12/30 a purchase made in 2018, clearing the following year
    expenses:food          5
    liabilities:pending

; in 2019.journal:
2019/1/2 clearance of last year\[aq]s pending transactions
    liabilities:pending    5 = 0
    assets:checking
\f[R]
.fi
.SS commodities
.PP
commodities
.PD 0
.P
.PD
List all commodity/currency symbols used or declared in the journal.
.SS descriptions
.PP
descriptions Show descriptions.
.PP
This command lists all descriptions that appear in transactions.
.PP
Examples:
.IP
.nf
\f[C]
$ hledger descriptions
Store Name
Gas Station | Petrol
Person A
\f[R]
.fi
.SS diff
.PP
diff
.PD 0
.P
.PD
Compares a particular account\[aq]s transactions in two input files.
It shows any transactions to this account which are in one file but not
in the other.
.PP
More precisely, for each posting affecting this account in either file,
it looks for a corresponding posting in the other file which posts the
same amount to the same account (ignoring date, description, etc.) Since
postings not transactions are compared, this also works when multiple
bank transactions have been combined into a single journal entry.
.PP
This is useful eg if you have downloaded an account\[aq]s transactions
from your bank (eg as CSV data).
When hledger and your bank disagree about the account balance, you can
compare the bank data with your journal to find out the cause.
.PP
Examples:
.IP
.nf
\f[C]
$ hledger diff -f $LEDGER_FILE -f bank.csv assets:bank:giro 
These transactions are in the first file only:

2014/01/01 Opening Balances
    assets:bank:giro              EUR ...
    ...
    equity:opening balances       EUR -...

These transactions are in the second file only:
\f[R]
.fi
.SS files
.PP
files
.PD 0
.P
.PD
List all files included in the journal.
With a REGEX argument, only file names matching the regular expression
(case sensitive) are shown.
.SS help
.PP
help
.PD 0
.P
.PD
Show any of the hledger manuals.
.PP
The \f[C]help\f[R] command displays any of the main hledger manuals, in
one of several ways.
Run it with no argument to list the manuals, or provide a full or
partial manual name to select one.
.PP
hledger manuals are available in several formats.
hledger help will use the first of these display methods that it finds:
info, man, $PAGER, less, stdout (or when non-interactive, just stdout).
You can force a particular viewer with the \f[C]--info\f[R],
\f[C]--man\f[R], \f[C]--pager\f[R], \f[C]--cat\f[R] flags.
.PP
Examples:
.IP
.nf
\f[C]
$ hledger help
Please choose a manual by typing \[dq]hledger help MANUAL\[dq] (a substring is ok).
Manuals: hledger hledger-ui hledger-web journal csv timeclock timedot
\f[R]
.fi
.IP
.nf
\f[C]
$ hledger help h --man

hledger(1)                    hledger User Manuals                    hledger(1)

NAME
       hledger - a command-line accounting tool

SYNOPSIS
       hledger [-f FILE] COMMAND [OPTIONS] [ARGS]
       hledger [-f FILE] ADDONCMD -- [OPTIONS] [ARGS]
       hledger

DESCRIPTION
       hledger  is  a  cross-platform  program  for tracking money, time, or any
\&...
\f[R]
.fi
.SS import
.PP
import
.PD 0
.P
.PD
Read new transactions added to each FILE since last run, and add them to
the main journal file.
Or with --dry-run, just print the transactions that would be added.
Or with --catchup, just mark all of the FILEs\[aq] transactions as
imported, without actually importing any.
.PP
The input files are specified as arguments - no need to write -f before
each one.
So eg to add new transactions from all CSV files to the main journal,
it\[aq]s just: \f[C]hledger import *.csv\f[R]
.PP
New transactions are detected in the same way as print --new: by
assuming transactions are always added to the input files in increasing
date order, and by saving \f[C].latest.FILE\f[R] state files.
.PP
The --dry-run output is in journal format, so you can filter it, eg to
see only uncategorised transactions:
.IP
.nf
\f[C]
$ hledger import --dry ... | hledger -f- print unknown --ignore-assertions
\f[R]
.fi
.SS Importing balance assignments
.PP
Entries added by import will have their posting amounts made explicit
(like \f[C]hledger print -x\f[R]).
This means that any balance assignments in imported files must be
evaluated; but, imported files don\[aq]t get to see the main file\[aq]s
account balances.
As a result, importing entries with balance assignments (eg from an
institution that provides only balances and not posting amounts) will
probably generate incorrect posting amounts.
To avoid this problem, use print instead of import:
.IP
.nf
\f[C]
$ hledger print IMPORTFILE [--new] >> $LEDGER_FILE
\f[R]
.fi
.PP
(If you think import should leave amounts implicit like print does,
please test it and send a pull request.)
.SS incomestatement
.PP
incomestatement, is
.PD 0
.P
.PD
This command displays a simple income statement, showing revenues and
expenses during a period.
It assumes that these accounts are under a top-level \f[C]revenue\f[R]
or \f[C]income\f[R] or \f[C]expense\f[R] account (case insensitive,
plural forms also allowed).
Note this report shows all account balances with normal positive sign
(like conventional financial statements, unlike balance/print/register)
(experimental).
.PP
This command displays a simple income statement.
It currently assumes that you have top-level accounts named
\f[C]income\f[R] (or \f[C]revenue\f[R]) and \f[C]expense\f[R] (plural
forms also allowed.)
.IP
.nf
\f[C]
$ hledger incomestatement
Income Statement

Revenues:
                 $-2  income
                 $-1    gifts
                 $-1    salary
--------------------
                 $-2

Expenses:
                  $2  expenses
                  $1    food
                  $1    supplies
--------------------
                  $2

Total:
--------------------
                   0
\f[R]
.fi
.PP
With a reporting interval, multiple columns will be shown, one for each
report period.
Normally incomestatement shows revenues/expenses per period, though as
with multicolumn balance reports you can alter the report mode with
\f[C]--change\f[R]/\f[C]--cumulative\f[R]/\f[C]--historical\f[R].
Instead of absolute values percentages can be displayed with
\f[C]-%\f[R].
.PP
This command also supports the output destination and output format
options The output formats supported are \f[C]txt\f[R], \f[C]csv\f[R],
\f[C]html\f[R], and (experimental) \f[C]json\f[R].
.SS notes
.PP
notes Show notes.
.PP
This command lists all notes that appear in transactions.
.PP
Examples:
.IP
.nf
\f[C]
$ hledger notes
Petrol
Snacks
\f[R]
.fi
.SS payees
.PP
payees Show payee names.
.PP
This command lists all payee names that appear in transactions.
.PP
Examples:
.IP
.nf
\f[C]
$ hledger payees
Store Name
Gas Station
Person A
\f[R]
.fi
.SS prices
.PP
prices
.PD 0
.P
.PD
Print market price directives from the journal.
With --costs, also print synthetic market prices based on transaction
prices.
With --inverted-costs, also print inverse prices based on transaction
prices.
Prices (and postings providing prices) can be filtered by a query.
Price amounts are always displayed with their full precision.
.SS print
.PP
print, txns, p
.PD 0
.P
.PD
Show transaction journal entries, sorted by date.
.PP
The print command displays full journal entries (transactions) from the
journal file in date order, tidily formatted.
With --date2, transactions are sorted by secondary date instead.
.PP
print\[aq]s output is always a valid hledger journal.
.PD 0
.P
.PD
It preserves all transaction information, but it does not preserve
directives or inter-transaction comments
.IP
.nf
\f[C]
$ hledger print
2008/01/01 income
    assets:bank:checking            $1
    income:salary                  $-1

2008/06/01 gift
    assets:bank:checking            $1
    income:gifts                   $-1

2008/06/02 save
    assets:bank:saving              $1
    assets:bank:checking           $-1

2008/06/03 * eat & shop
    expenses:food                $1
    expenses:supplies            $1
    assets:cash                 $-2

2008/12/31 * pay off
    liabilities:debts               $1
    assets:bank:checking           $-1
\f[R]
.fi
.PP
Normally, the journal entry\[aq]s explicit or implicit amount style is
preserved.
For example, when an amount is omitted in the journal, it will not
appear in the output.
Similarly, when a transaction price is implied but not written, it will
not appear in the output.
You can use the \f[C]-x\f[R]/\f[C]--explicit\f[R] flag to make all
amounts and transaction prices explicit, which can be useful for
troubleshooting or for making your journal more readable and robust
against data entry errors.
\f[C]-x\f[R] is also implied by using any of
\f[C]-B\f[R],\f[C]-V\f[R],\f[C]-X\f[R],\f[C]--value\f[R].
.PP
Note, \f[C]-x\f[R]/\f[C]--explicit\f[R] will cause postings with a
multi-commodity amount (these can arise when a multi-commodity
transaction has an implicit amount) to be split into multiple
single-commodity postings, keeping the output parseable.
.PP
With \f[C]-B\f[R]/\f[C]--cost\f[R], amounts with transaction prices are
converted to cost using that price.
This can be used for troubleshooting.
.PP
With \f[C]-m\f[R]/\f[C]--match\f[R] and a STR argument, print will show
at most one transaction: the one one whose description is most similar
to STR, and is most recent.
STR should contain at least two characters.
If there is no similar-enough match, no transaction will be shown.
.PP
With \f[C]--new\f[R], for each FILE being read, hledger reads (and
writes) a special state file (\f[C].latest.FILE\f[R] in the same
directory), containing the latest transaction date(s) that were seen
last time FILE was read.
When this file is found, only transactions with newer dates (and new
transactions on the latest date) are printed.
This is useful for ignoring already-seen entries in import data, such as
downloaded CSV files.
Eg:
.IP
.nf
\f[C]
$ hledger -f bank1.csv print --new
(shows transactions added since last print --new on this file)
\f[R]
.fi
.PP
This assumes that transactions added to FILE always have same or
increasing dates, and that transactions on the same day do not get
reordered.
See also the import command.
.PP
This command also supports the output destination and output format
options The output formats supported are \f[C]txt\f[R], \f[C]csv\f[R],
and (experimental) \f[C]json\f[R].
.PP
Here\[aq]s an example of print\[aq]s CSV output:
.IP
.nf
\f[C]
$ hledger print -Ocsv
\[dq]txnidx\[dq],\[dq]date\[dq],\[dq]date2\[dq],\[dq]status\[dq],\[dq]code\[dq],\[dq]description\[dq],\[dq]comment\[dq],\[dq]account\[dq],\[dq]amount\[dq],\[dq]commodity\[dq],\[dq]credit\[dq],\[dq]debit\[dq],\[dq]posting-status\[dq],\[dq]posting-comment\[dq]
\[dq]1\[dq],\[dq]2008/01/01\[dq],\[dq]\[dq],\[dq]\[dq],\[dq]\[dq],\[dq]income\[dq],\[dq]\[dq],\[dq]assets:bank:checking\[dq],\[dq]1\[dq],\[dq]$\[dq],\[dq]\[dq],\[dq]1\[dq],\[dq]\[dq],\[dq]\[dq]
\[dq]1\[dq],\[dq]2008/01/01\[dq],\[dq]\[dq],\[dq]\[dq],\[dq]\[dq],\[dq]income\[dq],\[dq]\[dq],\[dq]income:salary\[dq],\[dq]-1\[dq],\[dq]$\[dq],\[dq]1\[dq],\[dq]\[dq],\[dq]\[dq],\[dq]\[dq]
\[dq]2\[dq],\[dq]2008/06/01\[dq],\[dq]\[dq],\[dq]\[dq],\[dq]\[dq],\[dq]gift\[dq],\[dq]\[dq],\[dq]assets:bank:checking\[dq],\[dq]1\[dq],\[dq]$\[dq],\[dq]\[dq],\[dq]1\[dq],\[dq]\[dq],\[dq]\[dq]
\[dq]2\[dq],\[dq]2008/06/01\[dq],\[dq]\[dq],\[dq]\[dq],\[dq]\[dq],\[dq]gift\[dq],\[dq]\[dq],\[dq]income:gifts\[dq],\[dq]-1\[dq],\[dq]$\[dq],\[dq]1\[dq],\[dq]\[dq],\[dq]\[dq],\[dq]\[dq]
\[dq]3\[dq],\[dq]2008/06/02\[dq],\[dq]\[dq],\[dq]\[dq],\[dq]\[dq],\[dq]save\[dq],\[dq]\[dq],\[dq]assets:bank:saving\[dq],\[dq]1\[dq],\[dq]$\[dq],\[dq]\[dq],\[dq]1\[dq],\[dq]\[dq],\[dq]\[dq]
\[dq]3\[dq],\[dq]2008/06/02\[dq],\[dq]\[dq],\[dq]\[dq],\[dq]\[dq],\[dq]save\[dq],\[dq]\[dq],\[dq]assets:bank:checking\[dq],\[dq]-1\[dq],\[dq]$\[dq],\[dq]1\[dq],\[dq]\[dq],\[dq]\[dq],\[dq]\[dq]
\[dq]4\[dq],\[dq]2008/06/03\[dq],\[dq]\[dq],\[dq]*\[dq],\[dq]\[dq],\[dq]eat & shop\[dq],\[dq]\[dq],\[dq]expenses:food\[dq],\[dq]1\[dq],\[dq]$\[dq],\[dq]\[dq],\[dq]1\[dq],\[dq]\[dq],\[dq]\[dq]
\[dq]4\[dq],\[dq]2008/06/03\[dq],\[dq]\[dq],\[dq]*\[dq],\[dq]\[dq],\[dq]eat & shop\[dq],\[dq]\[dq],\[dq]expenses:supplies\[dq],\[dq]1\[dq],\[dq]$\[dq],\[dq]\[dq],\[dq]1\[dq],\[dq]\[dq],\[dq]\[dq]
\[dq]4\[dq],\[dq]2008/06/03\[dq],\[dq]\[dq],\[dq]*\[dq],\[dq]\[dq],\[dq]eat & shop\[dq],\[dq]\[dq],\[dq]assets:cash\[dq],\[dq]-2\[dq],\[dq]$\[dq],\[dq]2\[dq],\[dq]\[dq],\[dq]\[dq],\[dq]\[dq]
\[dq]5\[dq],\[dq]2008/12/31\[dq],\[dq]\[dq],\[dq]*\[dq],\[dq]\[dq],\[dq]pay off\[dq],\[dq]\[dq],\[dq]liabilities:debts\[dq],\[dq]1\[dq],\[dq]$\[dq],\[dq]\[dq],\[dq]1\[dq],\[dq]\[dq],\[dq]\[dq]
\[dq]5\[dq],\[dq]2008/12/31\[dq],\[dq]\[dq],\[dq]*\[dq],\[dq]\[dq],\[dq]pay off\[dq],\[dq]\[dq],\[dq]assets:bank:checking\[dq],\[dq]-1\[dq],\[dq]$\[dq],\[dq]1\[dq],\[dq]\[dq],\[dq]\[dq],\[dq]\[dq]
\f[R]
.fi
.IP \[bu] 2
There is one CSV record per posting, with the parent transaction\[aq]s
fields repeated.
.IP \[bu] 2
The \[dq]txnidx\[dq] (transaction index) field shows which postings
belong to the same transaction.
(This number might change if transactions are reordered within the file,
files are parsed/included in a different order, etc.)
.IP \[bu] 2
The amount is separated into \[dq]commodity\[dq] (the symbol) and
\[dq]amount\[dq] (numeric quantity) fields.
.IP \[bu] 2
The numeric amount is repeated in either the \[dq]credit\[dq] or
\[dq]debit\[dq] column, for convenience.
(Those names are not accurate in the accounting sense; it just puts
negative amounts under credit and zero or greater amounts under debit.)
.SS print-unique
.PP
print-unique
.PD 0
.P
.PD
Print transactions which do not reuse an already-seen description.
.PP
Example:
.IP
.nf
\f[C]
$ cat unique.journal
1/1 test
 (acct:one)  1
2/2 test
 (acct:two)  2
$ LEDGER_FILE=unique.journal hledger print-unique
(-f option not supported)
2015/01/01 test
    (acct:one)             1
\f[R]
.fi
.SS register
.PP
register, reg, r
.PD 0
.P
.PD
Show postings and their running total.
.PP
The register command displays postings in date order, one per line, and
their running total.
This is typically used with a query selecting a particular account, to
see that account\[aq]s activity:
.IP
.nf
\f[C]
$ hledger register checking
2008/01/01 income               assets:bank:checking            $1           $1
2008/06/01 gift                 assets:bank:checking            $1           $2
2008/06/02 save                 assets:bank:checking           $-1           $1
2008/12/31 pay off              assets:bank:checking           $-1            0
\f[R]
.fi
.PP
With --date2, it shows and sorts by secondary date instead.
.PP
The \f[C]--historical\f[R]/\f[C]-H\f[R] flag adds the balance from any
undisplayed prior postings to the running total.
This is useful when you want to see only recent activity, with a
historically accurate running balance:
.IP
.nf
\f[C]
$ hledger register checking -b 2008/6 --historical
2008/06/01 gift                 assets:bank:checking            $1           $2
2008/06/02 save                 assets:bank:checking           $-1           $1
2008/12/31 pay off              assets:bank:checking           $-1            0
\f[R]
.fi
.PP
The \f[C]--depth\f[R] option limits the amount of sub-account detail
displayed.
.PP
The \f[C]--average\f[R]/\f[C]-A\f[R] flag shows the running average
posting amount instead of the running total (so, the final number
displayed is the average for the whole report period).
This flag implies \f[C]--empty\f[R] (see below).
It is affected by \f[C]--historical\f[R].
It works best when showing just one account and one commodity.
.PP
The \f[C]--related\f[R]/\f[C]-r\f[R] flag shows the \f[I]other\f[R]
postings in the transactions of the postings which would normally be
shown.
.PP
The \f[C]--invert\f[R] flag negates all amounts.
For example, it can be used on an income account where amounts are
normally displayed as negative numbers.
It\[aq]s also useful to show postings on the checking account together
with the related account:
.IP
.nf
\f[C]
$ hledger register --related --invert assets:checking
\f[R]
.fi
.PP
With a reporting interval, register shows summary postings, one per
interval, aggregating the postings to each account:
.IP
.nf
\f[C]
$ hledger register --monthly income
2008/01                 income:salary                          $-1          $-1
2008/06                 income:gifts                           $-1          $-2
\f[R]
.fi
.PP
Periods with no activity, and summary postings with a zero amount, are
not shown by default; use the \f[C]--empty\f[R]/\f[C]-E\f[R] flag to see
them:
.IP
.nf
\f[C]
$ hledger register --monthly income -E
2008/01                 income:salary                          $-1          $-1
2008/02                                                          0          $-1
2008/03                                                          0          $-1
2008/04                                                          0          $-1
2008/05                                                          0          $-1
2008/06                 income:gifts                           $-1          $-2
2008/07                                                          0          $-2
2008/08                                                          0          $-2
2008/09                                                          0          $-2
2008/10                                                          0          $-2
2008/11                                                          0          $-2
2008/12                                                          0          $-2
\f[R]
.fi
.PP
Often, you\[aq]ll want to see just one line per interval.
The \f[C]--depth\f[R] option helps with this, causing subaccounts to be
aggregated:
.IP
.nf
\f[C]
$ hledger register --monthly assets --depth 1h
2008/01                 assets                                  $1           $1
2008/06                 assets                                 $-1            0
2008/12                 assets                                 $-1          $-1
\f[R]
.fi
.PP
Note when using report intervals, if you specify start/end dates these
will be adjusted outward if necessary to contain a whole number of
intervals.
This ensures that the first and last intervals are full length and
comparable to the others in the report.
.SS Custom register output
.PP
register uses the full terminal width by default, except on windows.
You can override this by setting the \f[C]COLUMNS\f[R] environment
variable (not a bash shell variable) or by using the
\f[C]--width\f[R]/\f[C]-w\f[R] option.
.PP
The description and account columns normally share the space equally
(about half of (width - 40) each).
You can adjust this by adding a description width as part of
--width\[aq]s argument, comma-separated: \f[C]--width W,D\f[R] .
Here\[aq]s a diagram (won\[aq]t display correctly in --help):
.IP
.nf
\f[C]
<--------------------------------- width (W) ---------------------------------->
date (10)  description (D)       account (W-41-D)     amount (12)   balance (12)
DDDDDDDDDD dddddddddddddddddddd  aaaaaaaaaaaaaaaaaaa  AAAAAAAAAAAA  AAAAAAAAAAAA
\f[R]
.fi
.PP
and some examples:
.IP
.nf
\f[C]
$ hledger reg                     # use terminal width (or 80 on windows)
$ hledger reg -w 100              # use width 100
$ COLUMNS=100 hledger reg         # set with one-time environment variable
$ export COLUMNS=100; hledger reg # set till session end (or window resize)
$ hledger reg -w 100,40           # set overall width 100, description width 40
$ hledger reg -w $COLUMNS,40      # use terminal width, & description width 40
\f[R]
.fi
.PP
This command also supports the output destination and output format
options The output formats supported are \f[C]txt\f[R], \f[C]csv\f[R],
and (experimental) \f[C]json\f[R].
.SS register-match
.PP
register-match
.PD 0
.P
.PD
Print the one posting whose transaction description is closest to DESC,
in the style of the register command.
If there are multiple equally good matches, it shows the most recent.
Query options (options, not arguments) can be used to restrict the
search space.
Helps ledger-autosync detect already-seen transactions when importing.
.SS rewrite
.PP
rewrite
.PD 0
.P
.PD
Print all transactions, rewriting the postings of matched transactions.
For now the only rewrite available is adding new postings, like print
--auto.
.PP
This is a start at a generic rewriter of transaction entries.
It reads the default journal and prints the transactions, like print,
but adds one or more specified postings to any transactions matching
QUERY.
The posting amounts can be fixed, or a multiplier of the existing
transaction\[aq]s first posting amount.
.PP
Examples:
.IP
.nf
\f[C]
$ hledger-rewrite.hs \[ha]income --add-posting \[aq](liabilities:tax)  *.33  ; income tax\[aq] --add-posting \[aq](reserve:gifts)  $100\[aq]
$ hledger-rewrite.hs expenses:gifts --add-posting \[aq](reserve:gifts)  *-1\[dq]\[aq]
$ hledger-rewrite.hs -f rewrites.hledger
\f[R]
.fi
.PP
rewrites.hledger may consist of entries like:
.IP
.nf
\f[C]
= \[ha]income amt:<0 date:2017
  (liabilities:tax)  *0.33  ; tax on income
  (reserve:grocery)  *0.25  ; reserve 25% for grocery
  (reserve:)  *0.25  ; reserve 25% for grocery
\f[R]
.fi
.PP
Note the single quotes to protect the dollar sign from bash, and the two
spaces between account and amount.
.PP
More:
.IP
.nf
\f[C]
$ hledger rewrite -- [QUERY]        --add-posting \[dq]ACCT  AMTEXPR\[dq] ...
$ hledger rewrite -- \[ha]income        --add-posting \[aq](liabilities:tax)  *.33\[aq]
$ hledger rewrite -- expenses:gifts --add-posting \[aq](budget:gifts)  *-1\[dq]\[aq]
$ hledger rewrite -- \[ha]income        --add-posting \[aq](budget:foreign currency)  *0.25 JPY; diversify\[aq]
\f[R]
.fi
.PP
Argument for \f[C]--add-posting\f[R] option is a usual posting of
transaction with an exception for amount specification.
More precisely, you can use \f[C]\[aq]*\[aq]\f[R] (star symbol) before
the amount to indicate that that this is a factor for an amount of
original matched posting.
If the amount includes a commodity name, the new posting amount will be
in the new commodity; otherwise, it will be in the matched posting
amount\[aq]s commodity.
.SS Re-write rules in a file
.PP
During the run this tool will execute so called \[dq]Automated
Transactions\[dq] found in any journal it process.
I.e instead of specifying this operations in command line you can put
them in a journal file.
.IP
.nf
\f[C]
$ rewrite-rules.journal
\f[R]
.fi
.PP
Make contents look like this:
.IP
.nf
\f[C]
= \[ha]income
    (liabilities:tax)  *.33

= expenses:gifts
    budget:gifts  *-1
    assets:budget  *1
\f[R]
.fi
.PP
Note that \f[C]\[aq]=\[aq]\f[R] (equality symbol) that is used instead
of date in transactions you usually write.
It indicates the query by which you want to match the posting to add new
ones.
.IP
.nf
\f[C]
$ hledger rewrite -- -f input.journal -f rewrite-rules.journal > rewritten-tidy-output.journal
\f[R]
.fi
.PP
This is something similar to the commands pipeline:
.IP
.nf
\f[C]
$ hledger rewrite -- -f input.journal \[aq]\[ha]income\[aq] --add-posting \[aq](liabilities:tax)  *.33\[aq] \[rs]
  | hledger rewrite -- -f - expenses:gifts      --add-posting \[aq]budget:gifts  *-1\[aq]       \[rs]
                                                --add-posting \[aq]assets:budget  *1\[aq]       \[rs]
  > rewritten-tidy-output.journal
\f[R]
.fi
.PP
It is important to understand that relative order of such entries in
journal is important.
You can re-use result of previously added postings.
.SS Diff output format
.PP
To use this tool for batch modification of your journal files you may
find useful output in form of unified diff.
.IP
.nf
\f[C]
$ hledger rewrite -- --diff -f examples/sample.journal \[aq]\[ha]income\[aq] --add-posting \[aq](liabilities:tax)  *.33\[aq]
\f[R]
.fi
.PP
Output might look like:
.IP
.nf
\f[C]
--- /tmp/examples/sample.journal
+++ /tmp/examples/sample.journal
\[at]\[at] -18,3 +18,4 \[at]\[at]
 2008/01/01 income
-    assets:bank:checking  $1
+    assets:bank:checking            $1
     income:salary
+    (liabilities:tax)                0
\[at]\[at] -22,3 +23,4 \[at]\[at]
 2008/06/01 gift
-    assets:bank:checking  $1
+    assets:bank:checking            $1
     income:gifts
+    (liabilities:tax)                0
\f[R]
.fi
.PP
If you\[aq]ll pass this through \f[C]patch\f[R] tool you\[aq]ll get
transactions containing the posting that matches your query be updated.
Note that multiple files might be update according to list of input
files specified via \f[C]--file\f[R] options and \f[C]include\f[R]
directives inside of these files.
.PP
Be careful.
Whole transaction being re-formatted in a style of output from
\f[C]hledger print\f[R].
.PP
See also:
.PP
https://github.com/simonmichael/hledger/issues/99
.SS rewrite vs. print --auto
.PP
This command predates print --auto, and currently does much the same
thing, but with these differences:
.IP \[bu] 2
with multiple files, rewrite lets rules in any file affect all other
files.
print --auto uses standard directive scoping; rules affect only child
files.
.IP \[bu] 2
rewrite\[aq]s query limits which transactions can be rewritten; all are
printed.
print --auto\[aq]s query limits which transactions are printed.
.IP \[bu] 2
rewrite applies rules specified on command line or in the journal.
print --auto applies rules specified in the journal.
.SS roi
.PP
roi
.PD 0
.P
.PD
Shows the time-weighted (TWR) and money-weighted (IRR) rate of return on
your investments.
.PP
This command assumes that you have account(s) that hold nothing but your
investments and whenever you record current appraisal/valuation of these
investments you offset unrealized profit and loss into account(s) that,
again, hold nothing but unrealized profit and loss.
.PP
Any transactions affecting balance of investment account(s) and not
originating from unrealized profit and loss account(s) are assumed to be
your investments or withdrawals.
.PP
At a minimum, you need to supply a query (which could be just an account
name) to select your investments with \f[C]--inv\f[R], and another query
to identify your profit and loss transactions with \f[C]--pnl\f[R].
.PP
It will compute and display the internalized rate of return (IRR) and
time-weighted rate of return (TWR) for your investments for the time
period requested.
Both rates of return are annualized before display, regardless of the
length of reporting interval.
.SS stats
.PP
stats
.PD 0
.P
.PD
Show some journal statistics.
.PP
The stats command displays summary information for the whole journal, or
a matched part of it.
With a reporting interval, it shows a report for each report period.
.PP
Example:
.IP
.nf
\f[C]
$ hledger stats
Main journal file        : /src/hledger/examples/sample.journal
Included journal files   : 
Transactions span        : 2008-01-01 to 2009-01-01 (366 days)
Last transaction         : 2008-12-31 (2333 days ago)
Transactions             : 5 (0.0 per day)
Transactions last 30 days: 0 (0.0 per day)
Transactions last 7 days : 0 (0.0 per day)
Payees/descriptions      : 5
Accounts                 : 8 (depth 3)
Commodities              : 1 ($)
Market prices            : 12 ($)
\f[R]
.fi
.PP
This command also supports output destination and output format
selection.
.SS tags
.PP
tags
.PD 0
.P
.PD
List all the tag names used in the journal.
With a TAGREGEX argument, only tag names matching the regular expression
(case insensitive) are shown.
With QUERY arguments, only transactions matching the query are
considered.
With --values flag, the tags\[aq] unique values are listed instead.
.SS test
.PP
test
.PD 0
.P
.PD
Run built-in unit tests.
.PP
This command runs the unit tests built in to hledger and hledger-lib,
printing the results on stdout.
If any test fails, the exit code will be non-zero.
.PP
This is mainly used by hledger developers, but you can also use it to
sanity-check the installed hledger executable on your platform.
All tests are expected to pass - if you ever see a failure, please
report as a bug!
.PP
This command also accepts tasty test runner options, written after a --
(double hyphen).
Eg to run only the tests in Hledger.Data.Amount, with ANSI colour codes
disabled:
.IP
.nf
\f[C]
$ hledger test -- -pData.Amount --color=never
\f[R]
.fi
.PP
For help on these, see https://github.com/feuerbach/tasty#options
(\f[C]-- --help\f[R] currently doesn\[aq]t show them).
.SS Add-on commands
.PP
hledger also searches for external add-on commands, and will include
these in the commands list.
These are programs or scripts in your PATH whose name starts with
\f[C]hledger-\f[R] and ends with a recognised file extension (currently:
no extension, \f[C]bat\f[R],\f[C]com\f[R],\f[C]exe\f[R],
\f[C]hs\f[R],\f[C]lhs\f[R],\f[C]pl\f[R],\f[C]py\f[R],\f[C]rb\f[R],\f[C]rkt\f[R],\f[C]sh\f[R]).
.PP
Add-ons can be invoked like any hledger command, but there are a few
things to be aware of.
Eg if the \f[C]hledger-web\f[R] add-on is installed,
.IP \[bu] 2
\f[C]hledger -h web\f[R] shows hledger\[aq]s help, while
\f[C]hledger web -h\f[R] shows hledger-web\[aq]s help.
.IP \[bu] 2
Flags specific to the add-on must have a preceding \f[C]--\f[R] to hide
them from hledger.
So \f[C]hledger web --serve --port 9000\f[R] will be rejected; you must
use \f[C]hledger web -- --serve --port 9000\f[R].
.IP \[bu] 2
You can always run add-ons directly if preferred:
\f[C]hledger-web --serve --port 9000\f[R].
.PP
Add-ons are a relatively easy way to add local features or experiment
with new ideas.
They can be written in any language, but haskell scripts have a big
advantage: they can use the same hledger (and haskell) library functions
that built-in commands do, for command-line options, journal parsing,
reporting, etc.
.PP
Two important add-ons are the hledger-ui and hledger-web user
interfaces.
These are maintained and released along with hledger:
.SS ui
.PP
hledger-ui provides an efficient terminal interface.
.SS web
.PP
hledger-web provides a simple web interface.
.PP
Third party add-ons, maintained separately from hledger, include:
.SS iadd
.PP
hledger-iadd is a more interactive, terminal UI replacement for the add
command.
.SS interest
.PP
hledger-interest generates interest transactions for an account
according to various schemes.
.PP
A few more experimental or old add-ons can be found in hledger\[aq]s
bin/ directory.
These are typically prototypes and not guaranteed to work.
.SH ENVIRONMENT
.PP
\f[B]COLUMNS\f[R] The screen width used by the register command.
Default: the full terminal width.
.PP
\f[B]LEDGER_FILE\f[R] The journal file path when not specified with
\f[C]-f\f[R].
Default: \f[C]\[ti]/.hledger.journal\f[R] (on windows, perhaps
\f[C]C:/Users/USER/.hledger.journal\f[R]).
.PP
A typical value is \f[C]\[ti]/DIR/YYYY.journal\f[R], where DIR is a
version-controlled finance directory and YYYY is the current year.
Or \f[C]\[ti]/DIR/current.journal\f[R], where current.journal is a
symbolic link to YYYY.journal.
.PP
On Mac computers, you can set this and other environment variables in a
more thorough way that also affects applications started from the GUI
(say, an Emacs dock icon).
Eg on MacOS Catalina I have a \f[C]\[ti]/.MacOSX/environment.plist\f[R]
file containing
.IP
.nf
\f[C]
{
  \[dq]LEDGER_FILE\[dq] : \[dq]\[ti]/finance/current.journal\[dq]
}
\f[R]
.fi
.PP
To see the effect you may need to \f[C]killall Dock\f[R], or reboot.
.SH FILES
.PP
Reads data from one or more files in hledger journal, timeclock,
timedot, or CSV format specified with \f[C]-f\f[R], or
\f[C]$LEDGER_FILE\f[R], or \f[C]$HOME/.hledger.journal\f[R] (on windows,
perhaps \f[C]C:/Users/USER/.hledger.journal\f[R]).
.SH LIMITATIONS
.PP
The need to precede addon command options with \f[C]--\f[R] when invoked
from hledger is awkward.
.PP
When input data contains non-ascii characters, a suitable system locale
must be configured (or there will be an unhelpful error).
Eg on POSIX, set LANG to something other than C.
.PP
In a Microsoft Windows CMD window, non-ascii characters and colours are
not supported.
.PP
On Windows, non-ascii characters may not display correctly when running
a hledger built in CMD in MSYS/CYGWIN, or vice-versa.
.PP
In a Cygwin/MSYS/Mintty window, the tab key is not supported in hledger
add.
.PP
Not all of Ledger\[aq]s journal file syntax is supported.
See file format differences.
.PP
On large data files, hledger is slower and uses more memory than Ledger.
.SH TROUBLESHOOTING
.PP
Here are some issues you might encounter when you run hledger (and
remember you can also seek help from the IRC channel, mail list or bug
tracker):
.PP
\f[B]Successfully installed, but \[dq]No command \[aq]hledger\[aq]
found\[dq]\f[R]
.PD 0
.P
.PD
stack and cabal install binaries into a special directory, which should
be added to your PATH environment variable.
Eg on unix-like systems, that is \[ti]/.local/bin and \[ti]/.cabal/bin
respectively.
.PP
\f[B]I set a custom LEDGER_FILE, but hledger is still using the default
file\f[R]
.PD 0
.P
.PD
\f[C]LEDGER_FILE\f[R] should be a real environment variable, not just a
shell variable.
The command \f[C]env | grep LEDGER_FILE\f[R] should show it.
You may need to use \f[C]export\f[R].
Here\[aq]s an explanation.
.PP
\f[B]Getting errors like \[dq]Illegal byte sequence\[dq] or \[dq]Invalid
or incomplete multibyte or wide character\[dq] or
\[dq]commitAndReleaseBuffer: invalid argument (invalid
character)\[dq]\f[R]
.PD 0
.P
.PD
Programs compiled with GHC (hledger, haskell build tools, etc.) need to
have a UTF-8-aware locale configured in the environment, otherwise they
will fail with these kinds of errors when they encounter non-ascii
characters.
.PP
To fix it, set the LANG environment variable to some locale which
supports UTF-8.
The locale you choose must be installed on your system.
.PP
Here\[aq]s an example of setting LANG temporarily, on Ubuntu GNU/Linux:
.IP
.nf
\f[C]
$ file my.journal
my.journal: UTF-8 Unicode text         # the file is UTF8-encoded
$ echo $LANG
C                                      # LANG is set to the default locale, which does not support UTF8
$ locale -a                            # which locales are installed ?
C
en_US.utf8                             # here\[aq]s a UTF8-aware one we can use
POSIX
$ LANG=en_US.utf8 hledger -f my.journal print   # ensure it is used for this command
\f[R]
.fi
.PP
If available, \f[C]C.UTF-8\f[R] will also work.
If your preferred locale isn\[aq]t listed by \f[C]locale -a\f[R], you
might need to install it.
Eg on Ubuntu/Debian:
.IP
.nf
\f[C]
$ apt-get install language-pack-fr
$ locale -a
C
en_US.utf8
fr_BE.utf8
fr_CA.utf8
fr_CH.utf8
fr_FR.utf8
fr_LU.utf8
POSIX
$ LANG=fr_FR.utf8 hledger -f my.journal print
\f[R]
.fi
.PP
Here\[aq]s how you could set it permanently, if you use a bash shell:
.IP
.nf
\f[C]
$ echo \[dq]export LANG=en_US.utf8\[dq] >>\[ti]/.bash_profile
$ bash --login
\f[R]
.fi
.PP
Exact spelling and capitalisation may be important.
Note the difference on MacOS (\f[C]UTF-8\f[R], not \f[C]utf8\f[R]).
Some platforms (eg ubuntu) allow variant spellings, but others (eg
macos) require it to be exact:
.IP
.nf
\f[C]
$ locale -a | grep -iE en_us.*utf
en_US.UTF-8
$ LANG=en_US.UTF-8 hledger -f my.journal print
\f[R]
.fi


.SH "REPORTING BUGS"
Report bugs at http://bugs.hledger.org
(or on the #hledger IRC channel or hledger mail list)

.SH AUTHORS
Simon Michael <simon@joyful.com> and contributors

.SH COPYRIGHT

Copyright (C) 2007-2019 Simon Michael.
.br
Released under GNU GPL v3 or later.

.SH SEE ALSO
hledger(1), hledger\-ui(1), hledger\-web(1), hledger\-api(1),
hledger_csv(5), hledger_journal(5), hledger_timeclock(5), hledger_timedot(5),
ledger(1)

http://hledger.org
